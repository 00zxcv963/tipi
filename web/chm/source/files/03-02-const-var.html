<!DOCTYPE html>
<html>
<head>
	<title>TIPI: 深入理解PHP内核</title>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<link href="chm.css" media="screen" rel="stylesheet" type="text/css" />
<link href="highlight.css" media="screen" rel="stylesheet" type="text/css" />
</head>
<body id="portable" class="pdf">
			<div class='page '>
			<h2>第二节 常量<a name='第二节 常量'></a></h2>

<p>常量，顾名思义是一个常态的量值。它与值只绑定一次，它的作用在于有肋于增加程序的可读性和可靠性。
在PHP中，常量的名字是一个简单值的标识符，在脚本执行期间该值不能改变。
和变量一样，常量默认为大小写敏感，但是按照我们的习惯常量标识符总是大写的。
常量名和其它任何 PHP 标签遵循同样的命名规则。合法的常量名以字母或下划线开始，后面跟着任何字母，数字或下划线。
在这一小节我们一起看下常量与我们常见的变量有啥区别，它在执行期间的不可改变的特性是如何实现的以及常量的定义过程。</p>

<p>首先看下常量与变量的区别，常量是在变量的zval结构的基础上添加了一额外的元素。如下所示为PHP中常量的内部结构。</p>

<h3>常量的内部结构<a name='常量的内部结构'></a></h3>

<pre class="c"><span class="kw4">typedef</span> <span class="kw4">struct</span> _zend_constant <span class="br0">&#123;</span>
    zval value<span class="sy0">;</span> <span class="coMULTI">/* zval结构，PHP内部变量的存储结构，在第一小节有说明 */</span>
    <span class="kw4">int</span> flags<span class="sy0">;</span>  <span class="coMULTI">/* 常量的标记如 CONST_PERSISTENT | CONST_CS */</span>
    <span class="kw4">char</span> <span class="sy0">*</span>name<span class="sy0">;</span> <span class="coMULTI">/* 常量名称 */</span>
    uint name_len<span class="sy0">;</span>  
    <span class="kw4">int</span> module_number<span class="sy0">;</span>  <span class="coMULTI">/* 模块号 */</span>
<span class="br0">&#125;</span> zend_constant<span class="sy0">;</span></pre>

<p>在Zend/zend_constants.h文件的33行可以看到如上所示的结构定义。
在常量的结构中，除了与变量一样的zval结构，它还包括属于常量的标记，常量名以及常量所在的模块号。</p>

<p>在了解了常量的存储结构后，我们来看PHP常量的定义过程。一个例子。</p>

<pre class="c">define<span class="br0">&#40;</span><span class="st0">'TIPI'</span><span class="sy0">,</span> <span class="st0">'Thinking In PHP Internal'</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>这是一个很常规的常量定义过程，它使用了PHP的内置函数<strong>define</strong>。常量名为TIPI，值为一个字符串，存放在zval结构中。
从这个例子出发，我们看下define定义常量的过程实现。</p>

<h3>define定义常量的过程<a name='define定义常量的过程'></a></h3>

<p>define是PHP的内置函数，在Zend/zend_builtin_functions.c文件中定义了此函数的实现。如下所示为部分源码：</p>

<pre class="c">&nbsp;
<span class="coMULTI">/* {{{ proto bool define(string constant_name, mixed value, boolean case_insensitive=false)
   Define a new constant */</span>
ZEND_FUNCTION<span class="br0">&#40;</span>define<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>zend_parse_parameters<span class="br0">&#40;</span>ZEND_NUM_ARGS<span class="br0">&#40;</span><span class="br0">&#41;</span> TSRMLS_CC<span class="sy0">,</span> <span class="st0">&quot;sz|b&quot;</span><span class="sy0">,</span> <span class="sy0">&amp;</span>name<span class="sy0">,</span>
                <span class="sy0">&amp;</span>name_len<span class="sy0">,</span> <span class="sy0">&amp;</span>val<span class="sy0">,</span> <span class="sy0">&amp;</span>non_cs<span class="br0">&#41;</span> <span class="sy0">==</span> FAILURE<span class="br0">&#41;</span> <span class="br0">&#123;</span>
                <span class="kw1">return</span><span class="sy0">;</span>
        <span class="br0">&#125;</span>
&nbsp;
        ... <span class="co1">// 类常量定义 此处不做介绍</span>
&nbsp;
        ... <span class="co1">// 值类型判断和处理</span>
&nbsp;
        c.<span class="me1">value</span> <span class="sy0">=</span> <span class="sy0">*</span>val<span class="sy0">;</span>
        zval_copy_ctor<span class="br0">&#40;</span><span class="sy0">&amp;</span>c.<span class="me1">value</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>val_free<span class="br0">&#41;</span> <span class="br0">&#123;</span>
                zval_ptr_dtor<span class="br0">&#40;</span><span class="sy0">&amp;</span>val_free<span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="br0">&#125;</span>
        c.<span class="me1">flags</span> <span class="sy0">=</span> case_sensitive<span class="sy0">;</span> <span class="coMULTI">/* non persistent */</span>
        c.<span class="me1">name</span> <span class="sy0">=</span> zend_strndup<span class="br0">&#40;</span>name<span class="sy0">,</span> name_len<span class="br0">&#41;</span><span class="sy0">;</span>
        c.<span class="me1">name_len</span> <span class="sy0">=</span> name_len<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">;</span>
        c.<span class="me1">module_number</span> <span class="sy0">=</span> PHP_USER_CONSTANT<span class="sy0">;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>zend_register_constant<span class="br0">&#40;</span><span class="sy0">&amp;</span>c TSRMLS_CC<span class="br0">&#41;</span> <span class="sy0">==</span> SUCCESS<span class="br0">&#41;</span> <span class="br0">&#123;</span>
                RETURN_TRUE<span class="sy0">;</span>
        <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
                RETURN_FALSE<span class="sy0">;</span>
        <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
<span class="coMULTI">/* }}} */</span></pre>

<p>上面的代码已经对对象和类常量做了简化处理，
其实现基本上是一个将传递的参数传递给新建的zend_constant结构，并将这个结构体注册到常量列表中的过程。
关于大小写敏感，函数的第三个参数表示是否<strong>大小不敏感</strong>，默认为false（大小写敏感）。这个参数最后会赋值给zend_constant结构体的flags字段。其在函数中实现代码如下：</p>

<pre class="c">zend_bool non_cs <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>   <span class="co1">//  第三个参数的临时存储变量</span>
<span class="kw4">int</span> case_sensitive <span class="sy0">=</span> CONST_CS<span class="sy0">;</span>  <span class="co1">//  是否大小写敏感，默认为1</span>
&nbsp;
<span class="kw1">if</span><span class="br0">&#40;</span>non_cs<span class="br0">&#41;</span> <span class="br0">&#123;</span>    <span class="co1">//  输入为真，大小写不敏感</span>
    case_sensitive <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
c.<span class="me1">flags</span> <span class="sy0">=</span> case_sensitive<span class="sy0">;</span> <span class="co1">//     赋值给结构体字段</span></pre>

<p>从上面的define函数的实现来看，<strong>PHP对于常量的名称在定义时其实是没有所谓的限制</strong>。如下所示代码：</p>

<pre class="php"><a href="http://www.php.net/define"><span class="kw3">define</span></a><span class="br0">&#40;</span><span class="st_h">'^_^'</span><span class="sy0">,</span> <span class="st_h">'smile'</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="kw1">if</span> <span class="br0">&#40;</span><a href="http://www.php.net/defined"><span class="kw3">defined</span></a><span class="br0">&#40;</span><span class="st_h">'^_^'</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <a href="http://www.php.net/echo"><span class="kw3">echo</span></a> <span class="st_h">'yes'</span><span class="sy0">;</span>
<span class="br0">&#125;</span><span class="kw1">else</span><span class="br0">&#123;</span>
    <a href="http://www.php.net/echo"><span class="kw3">echo</span></a> <span class="st_h">'no'</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
<span class="co1">//$var = ^_^;   //语法错误</span>
<span class="re0">$var</span> <span class="sy0">=</span> <a href="http://www.php.net/constant"><span class="kw3">constant</span></a><span class="br0">&#40;</span><span class="st0">&quot;^_^&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>通过defined函数测试表示，‘^_^’这个常量已经定义好，这样的常量无法直接调用，
只能使用constant语句来使用，
否则在语法解析时会显示错误。
在上面的代码中有用到一个判断常量是否定义的函数，下面我们看看这个函数是如何实现的。</p>

<h3>defined判断常量是否设置<a name='defined判断常量是否设置'></a></h3>

<p>和define一样， defined的实现也在Zend/zend_builtin_functions.c文件，
其实现是一个读取参数变量，调用 zend_get_constant_ex函数获取常量的值来判断常量是否存在的过程。
而zend_get_constant_ex函数不仅包括了常规的常规的常量获取，还包括类常量的获取，
最后是通过zend_get_constant函数获取常量的值。在zend_get_constant函数中，基本上是通过下面的代码来获取常量的值。</p>

<pre class="c">zend_hash_find<span class="br0">&#40;</span>EG<span class="br0">&#40;</span>zend_constants<span class="br0">&#41;</span><span class="sy0">,</span> name<span class="sy0">,</span> name_len<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> <span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">**</span><span class="br0">&#41;</span> <span class="sy0">&amp;</span>c<span class="br0">&#41;</span></pre>

<p>除此之外，只是调用这个函数之前和之后对name有一些特殊的处理。</p>

<h3>标准常量的初始化<a name='标准常量的初始化'></a></h3>

<p>以上通过define定义的常量的模块编号都是PHP_USER_CONSTANT，这表示是用户定义的常量。
除此之外我们在平时使用较多的，如在显示所有级别错误报告时使用的E_ALL常量就有点不同了。
这里我们以cgi模式为例说明标准常量的定义过程。
整个调用顺序如下所示：<br />
<strong>[php_cgi_startup() -> php_module_startup() -> zend_startup() -> zend_register_standard_constants()]</strong></p>

<pre class="c">&nbsp;
<span class="kw4">void</span> zend_register_standard_constants<span class="br0">&#40;</span>TSRMLS_D<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    ... <span class="co1">//  若干常量以REGISTER_MAIN_LONG_CONSTANT设置，</span>
    REGISTER_MAIN_LONG_CONSTANT<span class="br0">&#40;</span><span class="st0">&quot;E_ALL&quot;</span><span class="sy0">,</span> E_ALL<span class="sy0">,</span> CONST_PERSISTENT <span class="sy0">|</span> CONST_CS<span class="br0">&#41;</span><span class="sy0">;</span>
    ...
<span class="br0">&#125;</span></pre>

<p>REGISTER_MAIN_LONG_CONSTANT宏展开是以zend_register_long_constant实现。
zend_register_long_constant函数将常量中值的类型，值，名称及模块号赋值给新的zend_constant。
并调用zend_register_constant添加到全局的常量列表中。</p>

<p><strong>[php_cgi_startup() -> php_module_startup() -> zend_startup() -> zend_register_standard_constants() -> zend_register_constant]</strong></p>

<pre class="c">ZEND_API <span class="kw4">void</span> zend_register_long_constant<span class="br0">&#40;</span><span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>name<span class="sy0">,</span> uint name_len<span class="sy0">,</span>
        <span class="kw4">long</span> lval<span class="sy0">,</span> <span class="kw4">int</span> flags<span class="sy0">,</span> <span class="kw4">int</span> module_number TSRMLS_DC<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    zend_constant c<span class="sy0">;</span>
&nbsp;
    c.<span class="me1">value</span>.<span class="me1">type</span> <span class="sy0">=</span> IS_LONG<span class="sy0">;</span>
    c.<span class="me1">value</span>.<span class="me1">value</span>.<span class="me1">lval</span> <span class="sy0">=</span> lval<span class="sy0">;</span>
    c.<span class="me1">flags</span> <span class="sy0">=</span> flags<span class="sy0">;</span>
    c.<span class="me1">name</span> <span class="sy0">=</span> zend_strndup<span class="br0">&#40;</span>name<span class="sy0">,</span> name_len<span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
    c.<span class="me1">name_len</span> <span class="sy0">=</span> name_len<span class="sy0">;</span>
    c.<span class="me1">module_number</span> <span class="sy0">=</span> module_number<span class="sy0">;</span>
    zend_register_constant<span class="br0">&#40;</span><span class="sy0">&amp;</span>c TSRMLS_CC<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>zend_register_constant函数首先根据常量中的c->flags判断是否区分大小写，
如果不区分，则名字统一为小写，如果包含"&#92;&#92;"，也统一成小写。否则为定义的名字
然后将调用下面的语句将当前常量添加到EG(zend_constants)。
EG(zend_constants)是一个HashTable（这在前面的章节中说明），
下面的代码是将常量添加到这个HashTable中。</p>

<pre class="c">zend_hash_add<span class="br0">&#40;</span>EG<span class="br0">&#40;</span>zend_constants<span class="br0">&#41;</span><span class="sy0">,</span> name<span class="sy0">,</span> c<span class="sy0">-&gt;</span>name_len<span class="sy0">,</span> <span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">*</span><span class="br0">&#41;</span> c<span class="sy0">,</span>
        <span class="kw4">sizeof</span><span class="br0">&#40;</span>zend_constant<span class="br0">&#41;</span><span class="sy0">,</span> <span class="kw2">NULL</span><span class="br0">&#41;</span><span class="sy0">==</span>FAILURE<span class="br0">&#41;</span></pre>

<p>在php_module_startup函数中，除了zend_startup函数中有注册标准的常量，
它本身体通过宏REGISTER_MAIN_LONG_CONSTANT等注册了一些常量，如：PHP_VERSION，PHP_OS等。</p>

<p>关于接口和类中的常量我们将在后面的类所在章节中详细说明。</p>
		</div>
	</body>
</html>
