<!DOCTYPE html>
<html>
<head>
	<title>TIPI: 深入理解PHP内核</title>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<link href="chm.css" media="screen" rel="stylesheet" type="text/css" />
<link href="highlight.css" media="screen" rel="stylesheet" type="text/css" />
</head>
<body id="portable" class="pdf">
			<div class='page '>
			<h2>第六节 变量的生命周期<a name='第六节 变量的生命周期'></a></h2>

<p>通过前面章节的描述，我们已经知道了PHP中变量的存储方式－－所有的变量都保存在zval结构中。
下面介绍一下PHP内核如何实现变量的定义方式以及作用域。</p>

<h3>变量的生命周期<a name='变量的生命周期'></a></h3>

<p>在ZE进行词法和语法的分析之后，生成具体的opcode，这些opcode最终被execute函数(Zend/zend_vm_execute.h:46)解释执行。
在excute函数中，有以下代码：</p>

<pre class="c"><span class="kw1">while</span> <span class="br0">&#40;</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> 
&nbsp;
    ... 
    <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>ret <span class="sy0">=</span> EX<span class="br0">&#40;</span>opline<span class="br0">&#41;</span><span class="sy0">-&gt;</span>handler<span class="br0">&#40;</span>execute_data TSRMLS_CC<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">switch</span> <span class="br0">&#40;</span>ret<span class="br0">&#41;</span> <span class="br0">&#123;</span>
            <span class="kw1">case</span> <span class="nu0">1</span><span class="sy0">:</span>
                EG<span class="br0">&#40;</span>in_execution<span class="br0">&#41;</span> <span class="sy0">=</span> original_in_execution<span class="sy0">;</span>
                <span class="kw1">return</span><span class="sy0">;</span>
            <span class="kw1">case</span> <span class="nu0">2</span><span class="sy0">:</span>
                op_array <span class="sy0">=</span> EG<span class="br0">&#40;</span>active_op_array<span class="br0">&#41;</span><span class="sy0">;</span>
                <span class="kw1">goto</span> zend_vm_enter<span class="sy0">;</span>
            <span class="kw1">case</span> <span class="nu0">3</span><span class="sy0">:</span>
                execute_data <span class="sy0">=</span> EG<span class="br0">&#40;</span>current_execute_data<span class="br0">&#41;</span><span class="sy0">;</span>
            <span class="kw1">default</span><span class="sy0">:</span>
                <span class="kw2">break</span><span class="sy0">;</span>
        <span class="br0">&#125;</span>     
    <span class="br0">&#125;</span>     
    ...
<span class="br0">&#125;</span></pre>

<p>这里的EX(opline)->handler(...)将op_array中的操作顺序执行，
其中变量赋值操作在ZEND_ASSIGN_SPEC_CV_CONST_HANDLER()函数中进行。
ZEND_ASSIGN_SPEC_CV_CONST_HANDLER中进行一些变量类型的判断并在内存中分配一个zval，然后将变量的值存储其中。
变量名和指向这个zval的指针，则会存储于符号表内。
ZEND_ASSIGN_SPEC_CV_CONST_HANDLER的最后会调用ZEND_VM_NEXT_OPCODE()将op_array的指针移到下一条opline，
这样就会形成循环执行的效果。</p>

<p>在ZE执行的过程中，有四个全局的变量，这些变量都是用于ZE运行时所需信息的存储：</p>

<pre class="c"><span class="co1">//_zend_compiler_globals 编译时信息，包括函数表等</span>
zend_compiler_globals    <span class="sy0">*</span>compiler_globals<span class="sy0">;</span>  
<span class="co1">//_zend_executor_globals 执行时信息</span>
zend_executor_globals    <span class="sy0">*</span>executor_globals<span class="sy0">;</span> 
<span class="co1">//_php_core_globals 主要存储php.ini内的信息</span>
php_core_globals         <span class="sy0">*</span>core_globals<span class="sy0">;</span> 
<span class="co1">//_sapi_globals_struct SAPI的信息</span>
sapi_globals_struct      <span class="sy0">*</span>sapi_globals<span class="sy0">;</span></pre>

<p>在执行的过程中，变量名及指针主要存储于_zend_executor_globals的符号表中，_zend_executor_globals的结构这样的：</p>

<pre class="c"><span class="kw4">struct</span> _zend_executor_globals <span class="br0">&#123;</span>
...
<span class="coMULTI">/* symbol table cache */</span>
HashTable <span class="sy0">*</span>symtable_cache<span class="br0">&#91;</span>SYMTABLE_CACHE_SIZE<span class="br0">&#93;</span><span class="sy0">;</span>
HashTable <span class="sy0">**</span>symtable_cache_limit<span class="sy0">;</span>
HashTable <span class="sy0">**</span>symtable_cache_ptr<span class="sy0">;</span>
&nbsp;
zend_op <span class="sy0">**</span>opline_ptr<span class="sy0">;</span>
&nbsp;
HashTable <span class="sy0">*</span>active_symbol_table<span class="sy0">;</span>  <span class="coMULTI">/* active symbol table */</span>
HashTable symbol_table<span class="sy0">;</span>     <span class="coMULTI">/* main symbol table */</span>
&nbsp;
HashTable included_files<span class="sy0">;</span>   <span class="coMULTI">/* files already included */</span>
...
&nbsp;
<span class="br0">&#125;</span></pre>

<p>在执行的过程中，active_symbol_table会根据执行的具体语句不断发生变化(详请见本节下半部分)，针对线程安全的EG宏就是用来取此变量中的值。
ZE将op_array执行完毕以后，HashTable会被FREE_HASHTABLE()释放掉。
 如果程序使用了unset语句来主动消毁变量，则会调用ZEND_UNSET_VAR_SPEC_CV_HANDLER来将变量销毁，
回收内存，这部分内存可以参考《第六章 内存管理》的内容。</p>
		</div>
	</body>
</html>
