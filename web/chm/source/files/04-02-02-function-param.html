<!DOCTYPE html>
<html>
<head>
	<title>TIPI: 深入理解PHP内核</title>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<link href="chm.css" media="screen" rel="stylesheet" type="text/css" />
<link href="highlight.css" media="screen" rel="stylesheet" type="text/css" />
</head>
<body id="portable" class="pdf">
			<div class='page '>
			<h3>函数的参数<a name='函数的参数'></a></h3>

<p>前一小节介绍了函数的定义，函数的定义只是一个将函数名注册到函数列表的过程，在了解了函数的定义后，我们来看看函数的参数。
这一小节将包括用户自定义函数的参数和内部函数的参数两部分，详细内容如下：</p>

<h4>用户自定义函数的参数<a name='用户自定义函数的参数'></a></h4>

<p>在<a href="?p=chapt03/03-05-impl-of-type-hint">&lt;&lt;第三章第五小节 类型提示的实现>></a>中，我们对于参数的类型提示做了分析，这里我们在这一小节的基础上，进行一些更详细的说明。
在经过词语分析，语法分析后，我们知道对于函数的参数检查是通过 <strong>zend_do_receive_arg</strong> 函数来实现的。在此函数中对于参数的关键代码如下：</p>

<pre class="php">CG<span class="br0">&#40;</span>active_op_array<span class="br0">&#41;</span><span class="sy0">-&gt;</span><span class="me1">arg_info</span> <span class="sy0">=</span> erealloc<span class="br0">&#40;</span>CG<span class="br0">&#40;</span>active_op_array<span class="br0">&#41;</span><span class="sy0">-&gt;</span><span class="me1">arg_info</span><span class="sy0">,</span>
        <a href="http://www.php.net/sizeof"><span class="kw3">sizeof</span></a><span class="br0">&#40;</span>zend_arg_info<span class="br0">&#41;</span><span class="sy0">*</span><span class="br0">&#40;</span>CG<span class="br0">&#40;</span>active_op_array<span class="br0">&#41;</span><span class="sy0">-&gt;</span><span class="me1">num_args</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
cur_arg_info <span class="sy0">=</span> <span class="sy0">&amp;</span>CG<span class="br0">&#40;</span>active_op_array<span class="br0">&#41;</span><span class="sy0">-&gt;</span><span class="me1">arg_info</span><span class="br0">&#91;</span>CG<span class="br0">&#40;</span>active_op_array<span class="br0">&#41;</span><span class="sy0">-&gt;</span><span class="me1">num_args</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy0">;</span>
cur_arg_info<span class="sy0">-&gt;</span><span class="me1">name</span> <span class="sy0">=</span> estrndup<span class="br0">&#40;</span>varname<span class="sy0">-&gt;</span><span class="me1">u</span><span class="sy0">.</span><a href="http://www.php.net/constant"><span class="kw3">constant</span></a><span class="sy0">.</span>value<span class="sy0">.</span>str<span class="sy0">.</span>val<span class="sy0">,</span>
        varname<span class="sy0">-&gt;</span><span class="me1">u</span><span class="sy0">.</span><a href="http://www.php.net/constant"><span class="kw3">constant</span></a><span class="sy0">.</span>value<span class="sy0">.</span>str<span class="sy0">.</span>len<span class="br0">&#41;</span><span class="sy0">;</span>
cur_arg_info<span class="sy0">-&gt;</span><span class="me1">name_len</span> <span class="sy0">=</span> varname<span class="sy0">-&gt;</span><span class="me1">u</span><span class="sy0">.</span><a href="http://www.php.net/constant"><span class="kw3">constant</span></a><span class="sy0">.</span>value<span class="sy0">.</span>str<span class="sy0">.</span>len<span class="sy0">;</span>
cur_arg_info<span class="sy0">-&gt;</span><span class="me1">array_type_hint</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span>
cur_arg_info<span class="sy0">-&gt;</span><span class="me1">allow_null</span> <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
cur_arg_info<span class="sy0">-&gt;</span><span class="me1">pass_by_reference</span> <span class="sy0">=</span> pass_by_reference<span class="sy0">;</span>
cur_arg_info<span class="sy0">-&gt;</span><span class="me1">class_name</span> <span class="sy0">=</span> <span class="kw2">NULL</span><span class="sy0">;</span>
cur_arg_info<span class="sy0">-&gt;</span><span class="me1">class_name_len</span> <span class="sy0">=</span> <span class="nu0">0</span><span class="sy0">;</span></pre>

<p>整个参数的传递是通过给中间代码的arg_info字段执行赋值操作完成。关键点是在arg_info字段。arg_info字段的结构如下：</p>

<pre class="php">typedef struct _zend_arg_info <span class="br0">&#123;</span>
    <span class="kw2">const</span> char <span class="sy0">*</span>name<span class="sy0">;</span>   <span class="coMULTI">/* 参数的名称*/</span>
    zend_uint name_len<span class="sy0">;</span>     <span class="coMULTI">/* 参数名称的长度*/</span>
    <span class="kw2">const</span> char <span class="sy0">*</span>class_name<span class="sy0">;</span> <span class="coMULTI">/* 类名 */</span>
    zend_uint class_name_len<span class="sy0">;</span>   <span class="coMULTI">/* 类名长度*/</span>
    zend_bool array_type_hint<span class="sy0">;</span>  <span class="coMULTI">/* 数组类型提示 */</span>
    zend_bool allow_null<span class="sy0">;</span>   <span class="coMULTI">/* 是否允许为NULL　*/</span>
    zend_bool pass_by_reference<span class="sy0">;</span>    <span class="coMULTI">/*　是否引用传递 */</span>
    zend_bool return_reference<span class="sy0">;</span> 
    int required_num_args<span class="sy0">;</span>  
<span class="br0">&#125;</span> zend_arg_info<span class="sy0">;</span></pre>

<blockquote class='note'>
<p>参数的值传递和参数传递的区分是通过 <strong>pass_by_reference</strong>参数在生成中间代码时实现的。</p>
</blockquote>

<p>对于参数的个数，中间代码中包含的arg_nums字段在每次执行 **zend_do_receive_arg×× 时都会加1.如下代码：</p>

<pre class="php">CG<span class="br0">&#40;</span>active_op_array<span class="br0">&#41;</span><span class="sy0">-&gt;</span><span class="me1">num_args</span><span class="sy0">++;</span></pre>

<p>并且当前参数的索引为CG(active_op_array)->num_args-1 .如下代码：</p>

<pre class="php">cur_arg_info <span class="sy0">=</span> <span class="sy0">&amp;</span>CG<span class="br0">&#40;</span>active_op_array<span class="br0">&#41;</span><span class="sy0">-&gt;</span><span class="me1">arg_info</span><span class="br0">&#91;</span>CG<span class="br0">&#40;</span>active_op_array<span class="br0">&#41;</span><span class="sy0">-&gt;</span><span class="me1">num_args</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#93;</span><span class="sy0">;</span></pre>

<p>以上的分析是针对函数定义时的参数设置，这些参数是固定的。而在实际编写程序时可能我们会用到可变参数。
此时我们会使用到函数 <strong>func_num_args</strong> 和 <strong>func_get_args</strong>。
它们是以内部函数存在。于是在 Zend\zend_builtin_functions.c 文件中找到这两个函数的实现。
首先我们来看func_num_args函数的实现。其代码如下：</p>

<pre class="c"><span class="coMULTI">/* {{{ proto int func_num_args(void)
   Get the number of arguments that were passed to the function */</span>
ZEND_FUNCTION<span class="br0">&#40;</span>func_num_args<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    zend_execute_data <span class="sy0">*</span>ex <span class="sy0">=</span> EG<span class="br0">&#40;</span>current_execute_data<span class="br0">&#41;</span><span class="sy0">-&gt;</span>prev_execute_data<span class="sy0">;</span>
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>ex <span class="sy0">&amp;&amp;</span> ex<span class="sy0">-&gt;</span>function_state.<span class="me1">arguments</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        RETURN_LONG<span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw4">long</span><span class="br0">&#41;</span><span class="br0">&#40;</span>zend_uintptr_t<span class="br0">&#41;</span><span class="sy0">*</span><span class="br0">&#40;</span>ex<span class="sy0">-&gt;</span>function_state.<span class="me1">arguments</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        zend_error<span class="br0">&#40;</span>E_WARNING<span class="sy0">,</span>
<span class="st0">&quot;func_num_args():  Called from the global scope - no function context&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        RETURN_LONG<span class="br0">&#40;</span><span class="sy0">-</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
<span class="coMULTI">/* }}} */</span></pre>

<p>在存在 ex->function_state.arguments的情况下，即函数调用时，返回ex->function_state.arguments转化后的值 ，否则显示错误并返回-1。
这里最关键的一点是EG(current_execute_data)。这个变量存放的是当前执行程序或函数的数据。此时我们需要取前一个执行程序的数据，为什么呢？
因为这个函数的调用是在进入函数后执行的。函数的相关数据等都在之前执行过程中。于是调用的是：</p>

<pre class="c">zend_execute_data <span class="sy0">*</span>ex <span class="sy0">=</span> EG<span class="br0">&#40;</span>current_execute_data<span class="br0">&#41;</span><span class="sy0">-&gt;</span>prev_execute_data<span class="sy0">;</span></pre>

<blockquote class='note'>
<p>function_state等结构请参照本章第一小节。</p>
</blockquote>

<p>在了解func_num_args函数的实现后，func_get_args函数的实现过程就简单了，它们的数据源是一样的，
只是前面返回的是长度，而这里返回了一个创建的数组。数组中存放的是从ex->function_state.arguments转化后的数据。</p>

<h4>内部函数的参数<a name='内部函数的参数'></a></h4>

<p>以上我们所说的都是用户自定义函数中对于参数的相关内容。下面我们开始讲解内部函数是如何传递参数的。
以常见的count函数为例。其参数处理部分的代码如下：</p>

<pre class="c"><span class="coMULTI">/* {{{ proto int count(mixed var [, int mode])
   Count the number of elements in a variable (usually an array) */</span>
PHP_FUNCTION<span class="br0">&#40;</span>count<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    zval <span class="sy0">*</span>array<span class="sy0">;</span>
    <span class="kw4">long</span> mode <span class="sy0">=</span> COUNT_NORMAL<span class="sy0">;</span>
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>zend_parse_parameters<span class="br0">&#40;</span>ZEND_NUM_ARGS<span class="br0">&#40;</span><span class="br0">&#41;</span> TSRMLS_CC<span class="sy0">,</span> <span class="st0">&quot;z|l&quot;</span><span class="sy0">,</span>
         <span class="sy0">&amp;</span>array<span class="sy0">,</span> <span class="sy0">&amp;</span>mode<span class="br0">&#41;</span> <span class="sy0">==</span> FAILURE<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
    ... <span class="co1">//省略</span>
<span class="br0">&#125;</span></pre>

<p>这包括了两个操作：一个是取参数的个数，一个是解析参数列表。</p>

<p><strong>取参数的个数</strong></p>

<p>取参数的个数是通过ZEND_NUM_ARGS()宏来实现的。其定义如下：</p>

<pre class="c"><span class="co2">#define ZEND_NUM_ARGS()     (ht)</span></pre>

<blockquote class='note'>
<p>PHP3 中使用的是宏 ARG_COUNT</p>
</blockquote>

<p>ht是在 Zend/zend.h文件中定义的宏 <strong>INTERNAL_FUNCTION_PARAMETERS</strong> 中的ht，如下：</p>

<pre class="c"><span class="co2">#define INTERNAL_FUNCTION_PARAMETERS int ht, zval *return_value,</span>
zval <span class="sy0">**</span>return_value_ptr<span class="sy0">,</span> zval <span class="sy0">*</span>this_ptr<span class="sy0">,</span> <span class="kw4">int</span> return_value_used TSRMLS_DC</pre>

<p><strong>解析参数列表</strong></p>

<p>PHP内部函数在解析参数时使用的是 <strong>zend_parse_parameters</strong>。
它可以大大简化参数的接收处理工作，虽然它在处理可变参数时还有点弱。</p>

<p>其声明如下：</p>

<pre class="c">ZEND_API <span class="kw4">int</span> zend_parse_parameters<span class="br0">&#40;</span><span class="kw4">int</span> num_args TSRMLS_DC<span class="sy0">,</span> <span class="kw4">char</span> <span class="sy0">*</span>type_spec<span class="sy0">,</span> ...<span class="br0">&#41;</span></pre>

<ul>
<li>第一个参数num_args表明表示想要接收的参数个数，我们经常使用ZEND_NUM_ARGS() 来表示对传入的参数“有多少要多少”。</li>
<li>第二参数应该总是宏 TSRMLS_CC 。</li>
<li>第三个参数 type_spec 是一个字符串，用来指定我们所期待接收的各个参数的类型，有点类似于 printf 中指定输出格式的那个格式化字符串。</li>
<li>剩下的参数就是我们用来接收PHP参数值的变量的指针。</li>
</ul>

<p>zend_parse_parameters() 在解析参数的同时会尽可能地转换参数类型，这样就可以确保我们总是能得到所期望的类型的变量。
任何一种标量类型都可以转换为另外一种标量类型，但是不能在标量类型与复杂类型（比如数组、对象和资源等）之间进行转换。
如果成功地解析和接收到了参数并且在转换期间也没出现错误，那么这个函数就会返回 SUCCESS，否则返回 FAILURE。
如果这个函数不能接收到所预期的参数个数或者不能成功转换参数类型时就会抛出一些错误信息。</p>

<p>第三个参数指定的各个参数类型列表如下所示：</p>

<ul>
<li>l - 长整形</li>
<li>d - 双精度浮点类型</li>
<li>s - 字符串 (也可能是空字节)和其长度</li>
<li>b - 布尔型</li>
<li>r - 资源，保存在 zval*</li>
<li>a - 数组，保存在 zval*</li>
<li>o - （任何类的）对象，保存在 zval *</li>
<li>O - （由class entry 指定的类的）对象，保存在 zval *</li>
<li>z - 实际的 zval*</li>
</ul>

<p>除了各个参数类型，第三个参数还可以包含下面一些字符，它们的含义如下：</p>

<ul>
<li>| - 表明剩下的参数都是可选参数。如果用户没有传进来这些参数值，那么这些值就会被初始化成默认值。</li>
<li>/ - 表明参数解析函数将会对剩下的参数以 SEPARATE_ZVAL_IF_NOT_REF() 的方式来提供这个参数的一份拷贝，除非这些参数是一个引用。</li>
<li>! - 表明剩下的参数允许被设定为 NULL（仅用在 a、o、O、r和z身上）。如果用户传进来了一个 NULL 值，则存储该参数的变量将会设置为 NULL。</li>
</ul>
		</div>
	</body>
</html>
