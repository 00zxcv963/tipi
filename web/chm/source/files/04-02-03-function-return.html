<!DOCTYPE html>
<html>
<head>
	<title>TIPI: 深入理解PHP内核</title>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<link href="chm.css" media="screen" rel="stylesheet" type="text/css" />
<link href="highlight.css" media="screen" rel="stylesheet" type="text/css" />
</head>
<body id="portable" class="pdf">
			<div class='page '>
			<h3>函数的返回值<a name='函数的返回值'></a></h3>

<p>在编程语言中，一个函数或一个方法一般都有返回值，但也存在不返回值的情况，此时，这些函数仅仅仅是处理一些事务，
没有返回，或者说没有明确的返回值，在pascal语言中它有一个专有的关键字 <strong>procedure</strong> 。
在PHP中，函数都有返回值，分两种情况，使用return语句明确的返回和没有return语句返回NULL。</p>

<h4>return语句<a name='return语句'></a></h4>

<p>当使用return语句时，PHP给用户自定义的函数返回指定类型的变量。
依旧我们查看源码的方式，对return 关键字进行词法分析和语法分析后，生成中间代码。
从 Zend/zend_language_parser.y文件中可以确认其生成中间代码调用的是 <strong>zend_do_return</strong> 函数。</p>

<pre class="c"><span class="kw4">void</span> zend_do_return<span class="br0">&#40;</span>znode <span class="sy0">*</span>expr<span class="sy0">,</span> <span class="kw4">int</span> do_end_vparse TSRMLS_DC<span class="br0">&#41;</span> <span class="coMULTI">/* {{{ */</span>
<span class="br0">&#123;</span>
    zend_op <span class="sy0">*</span>opline<span class="sy0">;</span>
    <span class="kw4">int</span> start_op_number<span class="sy0">,</span> end_op_number<span class="sy0">;</span>
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>do_end_vparse<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>CG<span class="br0">&#40;</span>active_op_array<span class="br0">&#41;</span><span class="sy0">-&gt;</span>return_reference
                <span class="sy0">&amp;&amp;</span> <span class="sy0">!</span>zend_is_function_or_method_call<span class="br0">&#40;</span>expr<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
            zend_do_end_variable_parse<span class="br0">&#40;</span>expr<span class="sy0">,</span> BP_VAR_W<span class="sy0">,</span> <span class="nu0">0</span> TSRMLS_CC<span class="br0">&#41;</span><span class="sy0">;</span><span class="coMULTI">/* 处理返回引用 */</span>
        <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
            zend_do_end_variable_parse<span class="br0">&#40;</span>expr<span class="sy0">,</span> BP_VAR_R<span class="sy0">,</span> <span class="nu0">0</span> TSRMLS_CC<span class="br0">&#41;</span><span class="sy0">;</span><span class="coMULTI">/* 处理常规变量返回 */</span>
        <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
&nbsp;
   ...<span class="co1">// 省略  取其它中间代码操作</span>
&nbsp;
    opline<span class="sy0">-&gt;</span>opcode <span class="sy0">=</span> ZEND_RETURN<span class="sy0">;</span>
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>expr<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        opline<span class="sy0">-&gt;</span>op1 <span class="sy0">=</span> <span class="sy0">*</span>expr<span class="sy0">;</span>
&nbsp;
        <span class="kw1">if</span> <span class="br0">&#40;</span>do_end_vparse <span class="sy0">&amp;&amp;</span> zend_is_function_or_method_call<span class="br0">&#40;</span>expr<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
            opline<span class="sy0">-&gt;</span>extended_value <span class="sy0">=</span> ZEND_RETURNS_FUNCTION<span class="sy0">;</span>
        <span class="br0">&#125;</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        opline<span class="sy0">-&gt;</span>op1.<span class="me1">op_type</span> <span class="sy0">=</span> IS_CONST<span class="sy0">;</span>
        INIT_ZVAL<span class="br0">&#40;</span>opline<span class="sy0">-&gt;</span>op1.<span class="me1">u</span>.<span class="me1">constant</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&nbsp;
    SET_UNUSED<span class="br0">&#40;</span>opline<span class="sy0">-&gt;</span>op2<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
<span class="coMULTI">/* }}} */</span></pre>

<p>生成中间代码为 <strong>ZEND_RETURN</strong>。 第一个操作数的类型在返回值为可用的表达式时，
其类型为表达式的操作类型，否则类型为 IS_CONST。这在后续计算执行中间代码函数时有用到。
根据操作数的不同，ZEND_RETURN中间代码会执行 ZEND_RETURN_SPEC_CONST_HANDLER，
ZEND_RETURN_SPEC_TMP_HANDLER或ZEND_RETURN_SPEC_TMP_HANDLER。
这三个函数的执行流程基本类似，包括对一些错误的处理。
这里我们以ZEND_RETURN_SPEC_CONST_HANDLER为例说明函数返回值的执行过程：</p>

<pre class="c"><span class="kw4">static</span> <span class="kw4">int</span> ZEND_FASTCALL  ZEND_RETURN_SPEC_CONST_HANDLER<span class="br0">&#40;</span>ZEND_OPCODE_HANDLER_ARGS<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    zend_op <span class="sy0">*</span>opline <span class="sy0">=</span> EX<span class="br0">&#40;</span>opline<span class="br0">&#41;</span><span class="sy0">;</span>
    zval <span class="sy0">*</span>retval_ptr<span class="sy0">;</span>
    zval <span class="sy0">**</span>retval_ptr_ptr<span class="sy0">;</span>
&nbsp;
&nbsp;
    <span class="kw1">if</span> <span class="br0">&#40;</span>EG<span class="br0">&#40;</span>active_op_array<span class="br0">&#41;</span><span class="sy0">-&gt;</span>return_reference <span class="sy0">==</span> ZEND_RETURN_REF<span class="br0">&#41;</span> <span class="br0">&#123;</span>
&nbsp;
        <span class="co1">//  返回引用时不允许常量和临时变量</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span>IS_CONST <span class="sy0">==</span> IS_CONST <span class="sy0">||</span> IS_CONST <span class="sy0">==</span> IS_TMP_VAR<span class="br0">&#41;</span> <span class="br0">&#123;</span>   
            <span class="coMULTI">/* Not supposed to happen, but we'll allow it */</span>
            zend_error<span class="br0">&#40;</span>E_NOTICE<span class="sy0">,</span> <span class="st0">&quot;Only variable references <span class="es1">\
</span>                should be returned by reference&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
            <span class="kw1">goto</span> return_by_value<span class="sy0">;</span>
        <span class="br0">&#125;</span>
&nbsp;
        retval_ptr_ptr <span class="sy0">=</span> <span class="kw2">NULL</span><span class="sy0">;</span>  <span class="co1">//  返回值</span>
&nbsp;
        <span class="kw1">if</span> <span class="br0">&#40;</span>IS_CONST <span class="sy0">==</span> IS_VAR <span class="sy0">&amp;&amp;</span> <span class="sy0">!</span>retval_ptr_ptr<span class="br0">&#41;</span> <span class="br0">&#123;</span>
            zend_error_noreturn<span class="br0">&#40;</span>E_ERROR<span class="sy0">,</span> <span class="st0">&quot;Cannot return string offsets by reference&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="br0">&#125;</span>
&nbsp;
        <span class="kw1">if</span> <span class="br0">&#40;</span>IS_CONST <span class="sy0">==</span> IS_VAR <span class="sy0">&amp;&amp;</span> <span class="sy0">!</span>Z_ISREF_PP<span class="br0">&#40;</span>retval_ptr_ptr<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
            <span class="kw1">if</span> <span class="br0">&#40;</span>opline<span class="sy0">-&gt;</span>extended_value <span class="sy0">==</span> ZEND_RETURNS_FUNCTION <span class="sy0">&amp;&amp;</span>
                EX_T<span class="br0">&#40;</span>opline<span class="sy0">-&gt;</span>op1.<span class="me1">u</span>.<span class="me1">var</span><span class="br0">&#41;</span>.<span class="me1">var</span>.<span class="me1">fcall_returned_reference</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
            <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>EX_T<span class="br0">&#40;</span>opline<span class="sy0">-&gt;</span>op1.<span class="me1">u</span>.<span class="me1">var</span><span class="br0">&#41;</span>.<span class="me1">var</span>.<span class="me1">ptr_ptr</span> <span class="sy0">==</span>
                    <span class="sy0">&amp;</span>EX_T<span class="br0">&#40;</span>opline<span class="sy0">-&gt;</span>op1.<span class="me1">u</span>.<span class="me1">var</span><span class="br0">&#41;</span>.<span class="me1">var</span>.<span class="me1">ptr</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
                <span class="kw1">if</span> <span class="br0">&#40;</span>IS_CONST <span class="sy0">==</span> IS_VAR <span class="sy0">&amp;&amp;</span> <span class="sy0">!</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
                      <span class="coMULTI">/* undo the effect of get_zval_ptr_ptr() */</span>
                    PZVAL_LOCK<span class="br0">&#40;</span><span class="sy0">*</span>retval_ptr_ptr<span class="br0">&#41;</span><span class="sy0">;</span>
                <span class="br0">&#125;</span>
                zend_error<span class="br0">&#40;</span>E_NOTICE<span class="sy0">,</span> <span class="st0">&quot;Only variable references <span class="es1">\
</span>                 should be returned by reference&quot;</span><span class="br0">&#41;</span><span class="sy0">;</span>
                <span class="kw1">goto</span> return_by_value<span class="sy0">;</span>
            <span class="br0">&#125;</span>
        <span class="br0">&#125;</span>
&nbsp;
        <span class="kw1">if</span> <span class="br0">&#40;</span>EG<span class="br0">&#40;</span>return_value_ptr_ptr<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="co1">//  返回引用</span>
            SEPARATE_ZVAL_TO_MAKE_IS_REF<span class="br0">&#40;</span>retval_ptr_ptr<span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">//  is_ref__gc设置为1</span>
            Z_ADDREF_PP<span class="br0">&#40;</span>retval_ptr_ptr<span class="br0">&#41;</span><span class="sy0">;</span>    <span class="co1">//  refcount__gc计数加1</span>
&nbsp;
            <span class="br0">&#40;</span><span class="sy0">*</span>EG<span class="br0">&#40;</span>return_value_ptr_ptr<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">=</span> <span class="br0">&#40;</span><span class="sy0">*</span>retval_ptr_ptr<span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="br0">&#125;</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
return_by_value<span class="sy0">:</span>
&nbsp;
        retval_ptr <span class="sy0">=</span> <span class="sy0">&amp;</span>opline<span class="sy0">-&gt;</span>op1.<span class="me1">u</span>.<span class="me1">constant</span><span class="sy0">;</span>
&nbsp;
        <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span>EG<span class="br0">&#40;</span>return_value_ptr_ptr<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
            <span class="kw1">if</span> <span class="br0">&#40;</span>IS_CONST <span class="sy0">==</span> IS_TMP_VAR<span class="br0">&#41;</span> <span class="br0">&#123;</span>
&nbsp;
            <span class="br0">&#125;</span>
        <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span> <span class="coMULTI">/* Not a temp var */</span>
            <span class="kw1">if</span> <span class="br0">&#40;</span>IS_CONST <span class="sy0">==</span> IS_CONST <span class="sy0">||</span>
                EG<span class="br0">&#40;</span>active_op_array<span class="br0">&#41;</span><span class="sy0">-&gt;</span>return_reference <span class="sy0">==</span> ZEND_RETURN_REF <span class="sy0">||</span>
                <span class="br0">&#40;</span>PZVAL_IS_REF<span class="br0">&#40;</span>retval_ptr<span class="br0">&#41;</span> <span class="sy0">&amp;&amp;</span> Z_REFCOUNT_P<span class="br0">&#40;</span>retval_ptr<span class="br0">&#41;</span> <span class="sy0">&gt;</span> <span class="nu0">0</span><span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
                zval <span class="sy0">*</span>ret<span class="sy0">;</span>
&nbsp;
                ALLOC_ZVAL<span class="br0">&#40;</span>ret<span class="br0">&#41;</span><span class="sy0">;</span>
                INIT_PZVAL_COPY<span class="br0">&#40;</span>ret<span class="sy0">,</span> retval_ptr<span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">//  复制一份给返回值 </span>
                zval_copy_ctor<span class="br0">&#40;</span>ret<span class="br0">&#41;</span><span class="sy0">;</span>
                <span class="sy0">*</span>EG<span class="br0">&#40;</span>return_value_ptr_ptr<span class="br0">&#41;</span> <span class="sy0">=</span> ret<span class="sy0">;</span>
            <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
                <span class="sy0">*</span>EG<span class="br0">&#40;</span>return_value_ptr_ptr<span class="br0">&#41;</span> <span class="sy0">=</span> retval_ptr<span class="sy0">;</span> <span class="co1">//  直接赋值</span>
                Z_ADDREF_P<span class="br0">&#40;</span>retval_ptr<span class="br0">&#41;</span><span class="sy0">;</span>
            <span class="br0">&#125;</span>
        <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
            zval <span class="sy0">*</span>ret<span class="sy0">;</span>
&nbsp;
            ALLOC_ZVAL<span class="br0">&#40;</span>ret<span class="br0">&#41;</span><span class="sy0">;</span>
            INIT_PZVAL_COPY<span class="br0">&#40;</span>ret<span class="sy0">,</span> retval_ptr<span class="br0">&#41;</span><span class="sy0">;</span>    <span class="co1">//  复制一份给返回值 </span>
            <span class="sy0">*</span>EG<span class="br0">&#40;</span>return_value_ptr_ptr<span class="br0">&#41;</span> <span class="sy0">=</span> ret<span class="sy0">;</span>    
        <span class="br0">&#125;</span>
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw1">return</span> zend_leave_helper_SPEC<span class="br0">&#40;</span>ZEND_OPCODE_HANDLER_ARGS_PASSTHRU<span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">//  返回前执行收尾工作</span>
<span class="br0">&#125;</span></pre>

<p>函数的返回值在程序执行时存储在 *EG(return_value_ptr_ptr)。ZE内核对值返回和引用返回作了区分，
并且在此基础上对常量，临时变量和其它类型的变量在返回时进行了不同的处理。在return执行完之前，
ZE内核通过调用zend_leave_helper_SPEC函数，清除函数内部使用的变量等。
这也是ZE内核自动给函数加上NULL返回的原因之一。</p>

<h4>没有return语句的函数<a name='没有return语句的函数'></a></h4>

<p>在PHP中，没有过程这个概念，只有没有返回值的函数。但是对于没有返回值的函数，PHP内核会“帮你“加上一个NULL来做为返回值。
这个“帮你”的操作也是在生成中间代码时进行的。在每个函数解析时都需要执行函数 <strong>zend_do_end_function_declaration</strong>，
在此函数中有一条语句：</p>

<pre class="c">zend_do_return<span class="br0">&#40;</span><span class="kw2">NULL</span><span class="sy0">,</span> <span class="nu0">0</span> TSRMLS_CC<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>结合前面的内容，我们知道这条语句的作用就是返回NULL。这就是没有return语句的函数返回NULL的原因所在。</p>

<h4>内部函数的返回值<a name='内部函数的返回值'></a></h4>

<p>内部函数的返回值都是通过一个名为 return_value 的变量传递的。
这个变量同时也是函数中的一个参数，在PHP_FUNCTION函数扩展开来后可以看到。
这个参数总是包含有一个事先申请好空间的 zval 容器，因此你可以直接访问其成员并对其进行修改而无需先对 return_value 执行一下 MAKE_STD_ZVAL 宏指令。
为了能够更方便从函数中返回结果，也为了省却直接访问 zval 容器内部结构的麻烦，ZEND 提供了一大套宏命令来完成相关的这些操作。
这些宏命令会自动设置好类型和数值。</p>

<p><strong>从函数直接返回值的宏：</strong></p>

<ul>
<li>RETURN_RESOURCE(resource) 返回一个资源。</li>
<li>RETURN_BOOL(bool) 返回一个布尔值。</li>
<li>RETURN_NULL() 返回一个空值。</li>
<li>RETURN_LONG(long) 返回一个长整数。</li>
<li>RETURN_DOUBLE(double) 返回一个双精度浮点数。</li>
<li>RETURN_STRING(string, duplicate)  返回一个字符串。duplicate 表示这个字符是否使用 estrdup() 进行复制。</li>
<li>RETURN_STRINGL(string, length, duplicate) 返回一个定长的字符串。其余跟 RETURN_STRING 相同。这个宏速度更快而且是二进制安全的。</li>
<li>RETURN_EMPTY_STRING() 返回一个空字符串。</li>
<li>RETURN_FALSE  返回一个布尔值假。</li>
<li>RETURN_TRUE   返回一个布尔值真。</li>
</ul>

<p><strong>设置函数返回值的宏：</strong></p>

<ul>
<li>RETVAL_RESOURCE(resource) 设定返回值为指定的一个资源。</li>
<li>RETVAL_BOOL(bool) 设定返回值为指定的一个布尔值。</li>
<li>RETVAL_NULL   设定返回值为空值</li>
<li>RETVAL_LONG(long) 设定返回值为指定的一个长整数。</li>
<li>RETVAL_DOUBLE(double) 设定返回值为指定的一个双精度浮点数。</li>
<li>RETVAL_STRING(string, duplicate)  设定返回值为指定的一个字符串，duplicate 含义同 RETURN_STRING。</li>
<li>RETVAL_STRINGL(string, length, duplicate) 设定返回值为指定的一个定长的字符串。其余跟 RETVAL_STRING 相同。这个宏速度更快而且是二进制安全的。</li>
<li>RETVAL_EMPTY_STRING   设定返回值为空字符串。</li>
<li>RETVAL_FALSE  设定返回值为布尔值假。</li>
<li>RETVAL_TRUE   设定返回值为布尔值真。</li>
</ul>

<p>如果需要返回的是像数组和对象这样的复杂类型的数据，那就需要先调用 array_init() 和 object_init()，
也可以使用相应的 hash 函数直接操作 return_value。
由于这些类型主要是由一些杂七杂八的东西构成，所以对它们就没有了相应的宏。</p>

<p>关于内部函数的return_value值是如何赋值给*EG(return_value_ptr_ptr)，
函数的调用是如何进行的，请阅读下一小节 <a href="?p=chapt04/04-03-function-call">&lt;&lt;函数的调用和执行>></a>.</p>
		</div>
	</body>
</html>
