<!DOCTYPE html>
<html>
<head>
	<title>TIPI: 深入理解PHP内核</title>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<link href="chm.css" media="screen" rel="stylesheet" type="text/css" />
<link href="highlight.css" media="screen" rel="stylesheet" type="text/css" />
</head>
<body id="portable" class="pdf">
			<div class='page '>
			<h2>第三节 访问控制的实现<a name='第三节 访问控制的实现'></a></h2>

<p>面向对象的三大特性(封装、继承、多态)，其中封装是一个非常重要的特性。封装隐藏了对象内部的细节和实现，
使对象能够集中而完整的描述并对应一个具体的事物，
只提供对外的访问接口，这样可以在不改变接口的前提下改变实现细节，而且能使对象自我完备。
除此之外，封装还可以增强安全性和简化编程。
在面向对象的语言中一般是通过访问控制来实现封装的特性。
PHP提供了public、protected及private三个层次访问控制。这和其他面向对象的语言中对应的关键字语义一样。
这几个关键字都用于修饰类的成员:</p>

<ul>
<li>private 用于禁止除类本身以外(包括继承也属于非类本身)对成员的访问，用于隐藏类的内部数据和实现。</li>
<li>protectd 用于禁止除本类以及继承该类的类以外的任何访问。同样用于封装类的实现，同时给予类一定的扩展能力，
因为子类还是可以访问到这些成员。</li>
<li>public 最好理解，被public修饰的成员可以被任意的访问。</li>
</ul>

<blockquote class='note'>
<p>如果没有设置访问控制关键字，则类的成员方法和成员变量会被设置成默认的 public。</p>
</blockquote>

<p>这三个关键字在语法解析时分别对应三种访问控制的标记：</p>

<pre class="c">member_modifier<span class="sy0">:</span>
    T_PUBLIC                <span class="br0">&#123;</span> Z_LVAL<span class="br0">&#40;</span>$$.<span class="me1">u</span>.<span class="me1">constant</span><span class="br0">&#41;</span> <span class="sy0">=</span> ZEND_ACC_PUBLIC<span class="sy0">;</span> <span class="br0">&#125;</span>
<span class="sy0">|</span>   T_PROTECTED             <span class="br0">&#123;</span> Z_LVAL<span class="br0">&#40;</span>$$.<span class="me1">u</span>.<span class="me1">constant</span><span class="br0">&#41;</span> <span class="sy0">=</span> ZEND_ACC_PROTECTED<span class="sy0">;</span> <span class="br0">&#125;</span>
<span class="sy0">|</span>   T_PRIVATE               <span class="br0">&#123;</span> Z_LVAL<span class="br0">&#40;</span>$$.<span class="me1">u</span>.<span class="me1">constant</span><span class="br0">&#41;</span> <span class="sy0">=</span> ZEND_ACC_PRIVATE<span class="sy0">;</span> <span class="br0">&#125;</span></pre>

<p>这三种访问控制的标记是PHP内核中定义的三个常量，在Zend/zend_complic.h中，其定义如下：</p>

<pre class="c"><span class="co2">#define ZEND_ACC_PUBLIC     0x100</span>
<span class="co2">#define ZEND_ACC_PROTECTED  0x200</span>
<span class="co2">#define ZEND_ACC_PRIVATE    0x400</span>
<span class="co2">#define ZEND_ACC_PPP_MASK  (ZEND_ACC_PUBLIC | ZEND_ACC_PROTECTED | ZEND_ACC_PRIVATE)</span></pre>

<blockquote class='note'>
<p>我们经常使用16进制的数字表标示状态，例如上面的访问控制常量，
  0x100使用二进制表示就为 0001 0000 0000
  0x200为0010 0000 0000
  0x400为0100 0000 0000
  我们通过二进制的某个位来表示特定的意义，至于为什么ZEND_ACC_PUBLIC这几个常量后面多两个0，
  这是因为0x01和0x10已经被占用了，使用和其他不同意义的常量值不一样的值可以避免误用。
  通过简单的二进制&amp;即可的除某个数值是否表示特定的意义，例如:某个常量为0011 0000 0000，这个数值和 0001 0000 0000 做&amp;，
  如果结果为0则说明这个位上的值不为1，在上面的例子中就是这个访问控制不具有public的级别。
  当然PHP中不允许使用多个访问控制修饰符修饰同一个成员。这种处理方式在很多语言中都很常见。</p>
</blockquote>

<p>在前面有提到当我们没有给成员方法或成员变量设置访问控制时，其默认值为public。
与常规的访问控制实现一样，也是在语法解析阶段进行的。</p>

<pre class="c">method_modifiers<span class="sy0">:</span>
        <span class="coMULTI">/* empty */</span>
        <span class="br0">&#123;</span> Z_LVAL<span class="br0">&#40;</span>$$.<span class="me1">u</span>.<span class="me1">constant</span><span class="br0">&#41;</span> <span class="sy0">=</span> ZEND_ACC_PUBLIC<span class="sy0">;</span> <span class="br0">&#125;</span>
    <span class="sy0">|</span>   non_empty_member_modifiers          <span class="br0">&#123;</span> $$ <span class="sy0">=</span> $<span class="nu0">1</span><span class="sy0">;</span>  
        <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span><span class="br0">&#40;</span>Z_LVAL<span class="br0">&#40;</span>$$.<span class="me1">u</span>.<span class="me1">constant</span><span class="br0">&#41;</span> <span class="sy0">&amp;</span> ZEND_ACC_PPP_MASK<span class="br0">&#41;</span><span class="br0">&#41;</span>
        <span class="br0">&#123;</span> Z_LVAL<span class="br0">&#40;</span>$$.<span class="me1">u</span>.<span class="me1">constant</span><span class="br0">&#41;</span> <span class="sy0">|=</span> ZEND_ACC_PUBLIC<span class="sy0">;</span> <span class="br0">&#125;</span> <span class="br0">&#125;</span>
<span class="sy0">;</span></pre>

<p>虽然是在语法解析时就已经设置了访问控制，但其最终还是要存储在相关结构中。
在上面的语法解析过程中，访问控制已经存储在编译节点中，在编译具体的类成员时会传递给相关的结构。
此变量会作为一个参数传递给生成中间代码的函数。如在解析成员方法时，PHP内核是通过调用zend_do_begin_function_declaration
函数实现，此函数的第五个参数表示访问控制，在具体的代码中，</p>

<pre class="c"><span class="co1">// ...省略</span>
fn_flags <span class="sy0">=</span> Z_LVAL<span class="br0">&#40;</span>fn_flags_znode<span class="sy0">-&gt;</span>u.<span class="me1">constant</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="co1">// ... 省略</span>
&nbsp;
op_array.<span class="me1">fn_flags</span> <span class="sy0">|=</span> fn_flags<span class="sy0">;</span>
<span class="co1">//  ...省略</span></pre>

<p>如此，就将访问控制的相关参数传递给了将要执行的中间代码。 
假如我们先现在有下面一段代码：</p>

<pre class="php"><span class="kw2">class</span> Tipi<span class="br0">&#123;</span>
    <span class="kw2">private</span> <a href="http://www.php.net/static"><span class="kw3">static</span></a> <span class="kw2">function</span> t<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <a href="http://www.php.net/echo"><span class="kw3">echo</span></a> <span class="nu0">1</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
Tipi<span class="sy0">::</span><span class="me2">t</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>这个还是上一小节中我们说明静态成员方法的示例，只是，这里我们将其访问控制从public变成了private。
执行这段代码会报错：Fatal error: Call to private method Tipi::t() from context '' in...</p>

<p>根据前一节的内容我们知道，如果要执行一个静态成员变量需要先获得类，再获得类的方法，最后执行访方法。
而是否有访问权限的检测的实现过程在获取类的方法过程中，即在zend_std_get_static_method函数中。
此函数在获取了类的方法后，会执行访问控制的检查过程。</p>

<pre class="c"><span class="kw1">if</span> <span class="br0">&#40;</span>fbc<span class="sy0">-&gt;</span>op_array.<span class="me1">fn_flags</span> <span class="sy0">&amp;</span> ZEND_ACC_PUBLIC<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="co1">//公有方法，可以访问</span>
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span>fbc<span class="sy0">-&gt;</span>op_array.<span class="me1">fn_flags</span> <span class="sy0">&amp;</span> ZEND_ACC_PRIVATE<span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="co1">//  私有方法，报错</span>
<span class="br0">&#125;</span> <span class="kw1">else</span> <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>fbc<span class="sy0">-&gt;</span>common.<span class="me1">fn_flags</span> <span class="sy0">&amp;</span> ZEND_ACC_PROTECTED<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="co1">//  保护方法，报错</span>
<span class="br0">&#125;</span></pre>

<blockquote class='note'>
<p>见前面有关访问控制常量的讨论，这是使用的是 fbc->op_array.fn_flags &amp; ZEND_ACC_PUBLIC 而不是使用==来判断访问控制类型，
  通过这种方式，op_array.fn_flags中可以保存不止访问控制的信息，所以flag使用的是复数。</p>
</blockquote>

<p>对于成员函数来说，其对于访问控制存储在函数结构体中的fn_flags字段中，
不管是函数本身的common结构体中的fn_flags，还是函数包含所有中间代码的代码集合op_array中的fn_flags。</p>

<h3>访问控制的小漏洞<a name='访问控制的小漏洞'></a></h3>

<p>先看一个小例子吧：</p>

<pre class="php"><span class="kw2">&lt;?php</span>
&nbsp;
<span class="kw2">class</span> A <span class="br0">&#123;</span>
    <span class="kw2">private</span> <span class="re0">$money</span> <span class="sy0">=</span> <span class="nu0">10000</span><span class="sy0">;</span>
    <span class="kw2">public</span> <span class="kw2">function</span> doSth<span class="br0">&#40;</span><span class="re0">$anotherA</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="re0">$anotherA</span><span class="sy0">-&gt;</span><span class="me1">money</span> <span class="sy0">=</span> <span class="nu0">10000000000</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
&nbsp;
    <span class="kw2">public</span> <span class="kw2">function</span> getMoney<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">return</span> <span class="re0">$this</span><span class="sy0">-&gt;</span><span class="me1">money</span><span class="sy0">;</span>    
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="re0">$b</span> <span class="sy0">=</span> <span class="kw2">new</span> A<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<a href="http://www.php.net/echo"><span class="kw3">echo</span></a> <span class="re0">$b</span><span class="sy0">-&gt;</span><span class="me1">getMoney</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// 10000</span>
&nbsp;
<span class="re0">$a</span> <span class="sy0">=</span> <span class="kw2">new</span> A<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="re0">$a</span><span class="sy0">-&gt;</span><span class="me1">doSth</span><span class="br0">&#40;</span><span class="re0">$b</span><span class="br0">&#41;</span><span class="sy0">;</span>
<a href="http://www.php.net/echo"><span class="kw3">echo</span></a> <span class="re0">$b</span><span class="sy0">-&gt;</span><span class="me1">getMoney</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span> <span class="co1">// 10000000000;</span></pre>

<p>在$a变量的doSth()方法中我们直接修改了$b变量的私有成员money，当然我们不太可能这样写代码，从封装的角度来看，
这也是不应该的行为，从PHP实现的角度来看，这并不是一个功能，在其他语言中并不是这样表现的。这也是PHP面向对象不纯粹的表现之一。</p>

<p>下面我们从实现上面来看看是什么造就了这样的行为。以下函数为验证某个属性能否被访问的验证方法：</p>

<pre class="php"><a href="http://www.php.net/static"><span class="kw3">static</span></a> int zend_verify_property_access<span class="br0">&#40;</span>zend_property_info <span class="sy0">*</span>property_info<span class="sy0">,</span> zend_class_entry <span class="sy0">*</span>ce TSRMLS_DC<span class="br0">&#41;</span> <span class="coMULTI">/* {{{ */</span>
<span class="br0">&#123;</span>
    <span class="kw1">switch</span> <span class="br0">&#40;</span>property_info<span class="sy0">-&gt;</span><span class="me1">flags</span> <span class="sy0">&amp;</span> ZEND_ACC_PPP_MASK<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        <span class="kw1">case</span> ZEND_ACC_PUBLIC<span class="sy0">:</span>
            <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
        <span class="kw1">case</span> ZEND_ACC_PROTECTED<span class="sy0">:</span>
            <span class="kw1">return</span> zend_check_protected<span class="br0">&#40;</span>property_info<span class="sy0">-&gt;</span><span class="me1">ce</span><span class="sy0">,</span> EG<span class="br0">&#40;</span>scope<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">case</span> ZEND_ACC_PRIVATE<span class="sy0">:</span>
            <span class="kw1">if</span> <span class="br0">&#40;</span><span class="br0">&#40;</span>ce<span class="sy0">==</span>EG<span class="br0">&#40;</span>scope<span class="br0">&#41;</span> <span class="sy0">||</span> property_info<span class="sy0">-&gt;</span><span class="me1">ce</span> <span class="sy0">==</span> EG<span class="br0">&#40;</span>scope<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">&amp;&amp;</span> EG<span class="br0">&#40;</span>scope<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
                <span class="kw1">return</span> <span class="nu0">1</span><span class="sy0">;</span>
            <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
                <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
            <span class="br0">&#125;</span>
            <span class="kw1">break</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>
    <span class="kw1">return</span> <span class="nu0">0</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>在doSth()方法中，我们要访问$b对象的属性money，这是Zend引擎检查我们能否访问$b对象的这个属性，
这是Zend赢取获取$b对象的类，以及要访问的属性信息，首先要看看这个属性是否为public，公开的话直接访问就好了。
如果是protected的则继续调用zend_check_protected()函数检查，因为涉及到该类的父类，这里不继续跟这个函数了，
看看是private的情况下是什么情况，在函数doSth()执行的时候，这时的EG(scope)指向的正是类A，ce变量值得就是变量$b的类，
而$b的类就是类A，这样检查就判断成功返回1，也就表示可以访问。</p>

<p>至于成员函数的检查规则类似，就留给读者自己去探索了。</p>
		</div>
	</body>
</html>
