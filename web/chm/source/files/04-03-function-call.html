<!DOCTYPE html>
<html>
<head>
	<title>TIPI: 深入理解PHP内核</title>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<link href="chm.css" media="screen" rel="stylesheet" type="text/css" />
<link href="highlight.css" media="screen" rel="stylesheet" type="text/css" />
</head>
<body id="portable" class="pdf">
			<div class='page '>
			<h2>第三节 函数的调用和执行<a name='第三节 函数的调用和执行'></a></h2>

<p>前面小节中对函数的内部表示以及参数的传递，返回值都有了介绍，那函数是怎么被调用的呢？内置函数和用户定义函数在调用时会有什么不一样呢？
下面将介绍函数调用和执行的过程。</p>

<h3>函数的调用<a name='函数的调用'></a></h3>

<p>函数被调用需要一些基本的信息，比如函数的名称，参数以及函数的定义(也就是最终函数是怎么执行的)， 从我们开发者的角度来看，
定义了一个函数我们在执行的时候自然知道这个函数叫什么名字，以及调用的时候给传递了什么参数，以及函数是怎么执行的。
但是对于Zend引擎来说，它并不能像我们这样能“看懂”php源代码，他们需要对代码进行处理以后才能执行。我们还是从以下两个小例子开始：</p>

<pre class="php"><span class="kw2">&lt;?php</span>
    <span class="kw2">function</span> foo<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#123;</span>
        <a href="http://www.php.net/echo"><span class="kw3">echo</span></a> <span class="st0">&quot;I'm foo!&quot;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span>   
    foo<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
<span class="sy1">?&gt;</span></pre>

<p>下面我们先看一下其对应的opcodes：</p>

<pre class="php"><span class="kw2">function</span> name<span class="sy0">:</span>  <span class="br0">&#40;</span><span class="kw2">null</span><span class="br0">&#41;</span>
line     <span class="co2"># *  op                           fetch          ext  return  operands</span>
<span class="sy0">---------------------------------------------------------------------------------</span>
              DO_FCALL                                      <span class="nu0">0</span>          <span class="st_h">'foo'</span>
              NOP                                                      
            <span class="sy0">&gt;</span> <span class="kw1">RETURN</span>                                                   <span class="nu0">1</span>
&nbsp;
<span class="kw2">function</span> name<span class="sy0">:</span>  foo
line     <span class="co2"># *  op                           fetch          ext  return  operands</span>
<span class="sy0">---------------------------------------------------------------------------------</span>
   <span class="nu0">4</span>     <span class="nu0">0</span>  <span class="sy0">&gt;</span>   <a href="http://www.php.net/echo"><span class="kw3">ECHO</span></a>                                                     <span class="st_h">'I%27m+foo%21'</span>
   <span class="nu0">5</span>     <span class="nu0">1</span>    <span class="sy0">&gt;</span> <span class="kw1">RETURN</span>                                                   <span class="kw2">null</span></pre>

<p>上面是去除了一些枝节信息的的opcodes，可以看到执行时函数部分的opcodes是单独独立出来的，这点对于函数的执行特别重要，下面的部分会详细介绍。
现在，我们把焦点放到对foo函数的调用上面。调用foo的OPCODE是“DO_FCALL“， DO_FCALL进行函数调用操作时，ZE会在function_table中根据函数名
（如前所述，这里的函数名经过str_tolower的处理，所以PHP的函数名大小写不敏感)查找函数的定义， 如果不存在，
则报出“Call to undefined function xxx()"的错误信息; 如果存在，就返回该函数zend_function结构指针，
然后通过function.type的值来判断函数是内部函数还是用户定义的函数，
调用zend_execute_internal（zend_internal_function.handler）或者直接 调用zend_execute来执行这个函数包含的zend_op_array。</p>

<h3>函数的执行<a name='函数的执行'></a></h3>

<p>细心的读者可能会注意到上面opcodes里函数被调用的时候以及函数定义那都有个"function name:"，其实用户定义函数的执行与其他语句的执行并无区别，
在本质上看，其实函数中的php语句与函数外的php语句并无不同。函数体本身最大的区别，在于其执行环境的不同。
这个“执行环境”最重要的特征就是变量的作用域。大家都知道，函数内定义的变量在函数体外是无法直接使用的，反之也是一样。那么，在函数执行的时候，
进入函数前的环境信息是必须要保存的。在函数执行完毕后，这些环境信息也会被还原，使整个程序继续的执行下去。</p>

<p>内部函数的执行与用户函数不同。用户函数是php语句一条条“翻译”成op_line组成的一个op_array，而内部函数则是用C来实现的，因为执行环境也是C环境，
所以可以直接调用。如下面的例子：</p>

<pre class="txt">[php]   
&lt;?php
    $foo = 'test';
    print_r($foo);
?&gt;</pre>

<p>对应的opcodes也很简单：</p>

<pre class="c">line     <span class="co2"># *  op                           fetch          ext  return  operands</span>
<span class="sy0">---------------------------------------------------------------------------------</span>
   <span class="nu0">2</span>     <span class="nu0">0</span>  <span class="sy0">&gt;</span>   ASSIGN                                                   <span class="sy0">!</span><span class="nu0">0</span><span class="sy0">,</span> <span class="st0">'test'</span>
   <span class="nu0">3</span>     <span class="nu0">1</span>      SEND_VAR                                                 <span class="sy0">!</span><span class="nu0">0</span>
         <span class="nu0">2</span>      DO_FCALL                                      <span class="nu0">1</span>          <span class="st0">'print_r'</span>
   <span class="nu0">4</span>     <span class="nu0">3</span>    <span class="sy0">&gt;</span> <span class="kw1">RETURN</span>                                                   <span class="nu0">1</span></pre>

<p>可以看出，生成的opcodes中，内部函数和用户函数的处理都是由DO_FCALL来进行的。而在其具体实现的zend_do_fcall_common_helper_SPEC()中，
则对是否为内部函数进行了判断，如果是内部函数，则使用一个比较长的调用</p>

<pre class="c"><span class="br0">&#40;</span><span class="br0">&#40;</span>zend_internal_function <span class="sy0">*</span><span class="br0">&#41;</span> EX<span class="br0">&#40;</span>function_state<span class="br0">&#41;</span>.<span class="kw2">function</span><span class="br0">&#41;</span><span class="sy0">-&gt;</span>handler<span class="br0">&#40;</span>opline<span class="sy0">-&gt;</span>extended_value<span class="sy0">,</span> EX_T<span class="br0">&#40;</span>opline<span class="sy0">-&gt;</span>result.<span class="me1">u</span>.<span class="me1">var</span><span class="br0">&#41;</span>.<span class="me1">var</span>.<span class="me1">ptr</span><span class="sy0">,</span> EX<span class="br0">&#40;</span>function_state<span class="br0">&#41;</span>.<span class="me1">function</span><span class="sy0">-&gt;</span>common      .<span class="me1">return_reference</span><span class="sy0">?&amp;</span>EX_T<span class="br0">&#40;</span>opline<span class="sy0">-&gt;</span>result.<span class="me1">u</span>.<span class="me1">var</span><span class="br0">&#41;</span>.<span class="me1">var</span>.<span class="me1">ptr</span><span class="sy0">:</span><span class="kw2">NULL</span><span class="sy0">,</span> EX<span class="br0">&#40;</span>object<span class="br0">&#41;</span><span class="sy0">,</span> RETURN_VALUE_USED<span class="br0">&#40;</span>opline<span class="br0">&#41;</span> TSRMLS_CC<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>上面这种方式的内部函数是在zend_execute_internal函数没有定义的情况下。而在而在Zend/zend.c文件的zend_startup函数中，</p>

<pre class="c">zend_execute_internal <span class="sy0">=</span> <span class="kw2">NULL</span><span class="sy0">;</span></pre>

<p>此函数确实被赋值为NULL。于是我们在if (!zend_execute_internal)判断时会成立，所以我们是执行那段很长的调用。
那么，这段很长的调用到底是什么呢？以我们常用的 <strong>count</strong>函数为例。在<a href="?p=chapt04/04-01-function-struct">&lt;&lt;第一节 函数的内部结构>></a>中，
我们知道内部函数所在的结构体中
有一个handler指针指向此函数需要调用的内部定义的C函数。
这些内部函数在模块初始化时就以扩展的函数的形式加载到EG(function_table)。其调用顺序：</p>

<pre class="shell">php_module_startup --&gt; php_register_extensions --&gt; zend_register_internal_module
--&gt; zend_register_module_ex --&gt; zend_register_functions
&nbsp;
zend_register_functions(NULL, module-&gt;functions, NULL, module-&gt;type TSRMLS_CC)</pre>

<p>在standard扩展中。module的定义为：</p>

<pre class="c">zend_module_entry basic_functions_module <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="coMULTI">/* {{{ */</span>
    STANDARD_MODULE_HEADER_EX<span class="sy0">,</span>
    <span class="kw2">NULL</span><span class="sy0">,</span>
    standard_deps<span class="sy0">,</span>
    <span class="st0">&quot;standard&quot;</span><span class="sy0">,</span>                 <span class="coMULTI">/* extension name */</span>
    basic_functions<span class="sy0">,</span>            <span class="coMULTI">/* function list */</span>
    ... <span class="co1">//省略</span>
<span class="br0">&#125;</span></pre>

<p>从上面的代码可以看出，module->functions是指向basic_functions。在basic_functions.c文件中查找basic_functions的定义。</p>

<pre class="c"><span class="kw4">const</span> zend_function_entry basic_functions<span class="br0">&#91;</span><span class="br0">&#93;</span> <span class="sy0">=</span> <span class="br0">&#123;</span> <span class="coMULTI">/* {{{ */</span>
    ...<span class="co1">//   省略</span>
    PHP_FE<span class="br0">&#40;</span>count<span class="sy0">,</span>                                                           arginfo_count<span class="br0">&#41;</span>
    ...<span class="co1">//省略</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="co2">#define PHP_FE          ZEND_FE</span>
<span class="co2">#define ZEND_FE(name, arg_info)                     ZEND_FENTRY(name, ZEND_FN(name), arg_info, 0)</span>
<span class="co2">#define ZEND_FN(name) zif_##name</span>
<span class="co2">#define ZEND_FENTRY(zend_name, name, arg_info, flags)   { #zend_name, name, arg_info, (zend_uint) (sizeof(arg_info)/sizeof(struct _zend_arg_info)-1), flags },</span></pre>

<p>综合上面的代码，count函数最后调用的函数名为zif_count，但是此函数对外的函数名还是为count。
调用的函数名name以第二个元素存放在zend_function_entry结构体数组中。
对于zend_function_entry的结构</p>

<pre class="c"><span class="kw4">typedef</span> <span class="kw4">struct</span> _zend_function_entry <span class="br0">&#123;</span>
    <span class="kw4">const</span> <span class="kw4">char</span> <span class="sy0">*</span>fname<span class="sy0">;</span>
    <span class="kw4">void</span> <span class="br0">&#40;</span><span class="sy0">*</span>handler<span class="br0">&#41;</span><span class="br0">&#40;</span>INTERNAL_FUNCTION_PARAMETERS<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw4">const</span> <span class="kw4">struct</span> _zend_arg_info <span class="sy0">*</span>arg_info<span class="sy0">;</span>
    zend_uint num_args<span class="sy0">;</span>
    zend_uint flags<span class="sy0">;</span>
<span class="br0">&#125;</span> zend_function_entry<span class="sy0">;</span></pre>

<p>第二个元素为handler。这也就是我们在执行内部函数时的调用方法。因此在执行时就会调用到对应的函数。</p>

<p>对于用户定义的函数，在zend_do_fcall_common_helper_SPEC()函数中，</p>

<pre class="c"><span class="kw1">if</span> <span class="br0">&#40;</span>EX<span class="br0">&#40;</span>function_state<span class="br0">&#41;</span>.<span class="me1">function</span><span class="sy0">-&gt;</span>type <span class="sy0">==</span> ZEND_USER_FUNCTION <span class="sy0">||</span>
    EX<span class="br0">&#40;</span>function_state<span class="br0">&#41;</span>.<span class="me1">function</span><span class="sy0">-&gt;</span>common.<span class="me1">scope</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    should_change_scope <span class="sy0">=</span> <span class="nu0">1</span><span class="sy0">;</span>
    EX<span class="br0">&#40;</span>current_this<span class="br0">&#41;</span> <span class="sy0">=</span> EG<span class="br0">&#40;</span>This<span class="br0">&#41;</span><span class="sy0">;</span>
    EX<span class="br0">&#40;</span>current_scope<span class="br0">&#41;</span> <span class="sy0">=</span> EG<span class="br0">&#40;</span>scope<span class="br0">&#41;</span><span class="sy0">;</span>
    EX<span class="br0">&#40;</span>current_called_scope<span class="br0">&#41;</span> <span class="sy0">=</span> EG<span class="br0">&#40;</span>called_scope<span class="br0">&#41;</span><span class="sy0">;</span>
    EG<span class="br0">&#40;</span>This<span class="br0">&#41;</span> <span class="sy0">=</span> EX<span class="br0">&#40;</span>object<span class="br0">&#41;</span><span class="sy0">;</span>
    EG<span class="br0">&#40;</span>scope<span class="br0">&#41;</span> <span class="sy0">=</span> <span class="br0">&#40;</span>EX<span class="br0">&#40;</span>function_state<span class="br0">&#41;</span>.<span class="me1">function</span><span class="sy0">-&gt;</span>type <span class="sy0">==</span> ZEND_USER_FUNCTION <span class="sy0">||</span> <span class="sy0">!</span>EX<span class="br0">&#40;</span>object<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="sy0">?</span> EX<span class="br0">&#40;</span>function_state<span class="br0">&#41;</span>.<span class="me1">function</span><span class="sy0">-&gt;</span>common.<span class="me1">scope</span> <span class="sy0">:</span> <span class="kw2">NULL</span><span class="sy0">;</span>
    EG<span class="br0">&#40;</span>called_scope<span class="br0">&#41;</span> <span class="sy0">=</span> EX<span class="br0">&#40;</span>called_scope<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>先将EG下的This，scope等暂时缓存起来（这些在后面会都恢复到此时缓存的数据）。在此之后，对于用户自定义的函数，
程序会依据zend_execute是否等于execute并且是否为异常来判断是返回，还是直接执行函数定义的op_array：</p>

<pre class="c"><span class="kw1">if</span> <span class="br0">&#40;</span>zend_execute <span class="sy0">==</span> execute <span class="sy0">&amp;&amp;</span> <span class="sy0">!</span>EG<span class="br0">&#40;</span>exception<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
        EX<span class="br0">&#40;</span>call_opline<span class="br0">&#41;</span> <span class="sy0">=</span> opline<span class="sy0">;</span>
        ZEND_VM_ENTER<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        zend_execute<span class="br0">&#40;</span>EG<span class="br0">&#40;</span>active_op_array<span class="br0">&#41;</span> TSRMLS_CC<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span></pre>

<p>而在Zend/zend.c文件的zend_startup函数中，已将zend_execute赋值为：</p>

<pre class="c">zend_execute <span class="sy0">=</span> execute<span class="sy0">;</span></pre>

<p>从而对于异常，程序会抛出异常；其它情况，程序会调用execute执行此函数中生成的opcodes。
execute函数会遍历所传递给它的zend_op_array数组，以方式</p>

<pre class="c">ret <span class="sy0">=</span> EX<span class="br0">&#40;</span>opline<span class="br0">&#41;</span><span class="sy0">-&gt;</span>handler<span class="br0">&#40;</span>execute_data TSRMLS_CC<span class="br0">&#41;</span></pre>

<p>调用每个opcode的处理函数。而execute_data在execute函数开始时就已经给其分配了空间，这就是这个函数的执行环境。</p>
		</div>
	</body>
</html>
