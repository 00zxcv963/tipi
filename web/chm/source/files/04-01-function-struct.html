<!DOCTYPE html>
<html>
<head>
	<title>TIPI: 深入理解PHP内核</title>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<link href="chm.css" media="screen" rel="stylesheet" type="text/css" />
<link href="highlight.css" media="screen" rel="stylesheet" type="text/css" />
</head>
<body id="portable" class="pdf">
			<div class='page '>
			<h2>第一节 函数的内部结构<a name='第一节 函数的内部结构'></a></h2>

<p>在PHP中，函数有自己的作用域，同时在其内部可以实现各种语句的执行，最后返回最终结果值。
在PHP的源码中可以发现，PHP内核将函数分为以下类型：</p>

<pre class="c"><span class="co2">#define ZEND_INTERNAL_FUNCTION              1</span>
<span class="co2">#define ZEND_USER_FUNCTION                  2  </span>
<span class="co2">#define ZEND_OVERLOADED_FUNCTION            3</span>
<span class="co2">#define ZEND_EVAL_CODE                      4</span>
<span class="co2">#define ZEND_OVERLOADED_FUNCTION_TEMPORARY  5</span></pre>

<p>其中的<em>ZEND_USER_FUNCTION</em>是用户函数，<em>ZEND_INTERNAL_FUNCTION</em>是内置的函数。也就是说PHP将内置的函数和
用户定义的函数分别保存。</p>

<h3>1.用户函数(ZEND_USER_FUNCTION)<a name='1.用户函数(ZEND_USER_FUNCTION)'></a></h3>

<p>用户自定义函数是非常常用的函数种类，如下面的代码，定义了一个用户自定义的函数：</p>

<pre class="php"><span class="kw2">&lt;?php</span> 
&nbsp;
<span class="kw2">function</span> tipi<span class="br0">&#40;</span> <span class="re0">$name</span> <span class="br0">&#41;</span><span class="br0">&#123;</span>
    <span class="re0">$return</span> <span class="sy0">=</span> <span class="st0">&quot;Hi! &quot;</span> <span class="sy0">.</span> <span class="re0">$name</span><span class="sy0">;</span>
    <a href="http://www.php.net/echo"><span class="kw3">echo</span></a> <span class="re0">$return</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="re0">$return</span><span class="sy0">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="sy1">?&gt;</span></pre>

<p>这个示例中，对自定义函数传入了一个参数，并将其与<em>Hi!</em> 一起输出并做为返回值返回。
从这个例子可以看出函数的基本特点：运行时声明、可以传参数、有值返回。
当然，有些函数只是进行一些操作，并不一定显式的有返回值，在PHP的实现中，即使没有显式的返回，
PHP内核也会“帮你“返回NULL。</p>

<p>通过 <a href="?p=chapt03/03-06-00-scope">&lt;&lt;第六节 变量的作用域>></a> 可知，ZE在执行过程中，会将运行时信息存储于_zend_execute_data中：</p>

<pre class="c"><span class="kw4">struct</span> _zend_execute_data <span class="br0">&#123;</span>
    <span class="co1">//...省略部分代码</span>
    zend_function_state function_state<span class="sy0">;</span>
    zend_function <span class="sy0">*</span>fbc<span class="sy0">;</span> <span class="coMULTI">/* Function Being Called */</span>
    <span class="co1">//...省略部分代码</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>在程序初始化的过程中，function_state也会进行初始化，function_state由两个部分组成：</p>

<pre class="c"><span class="kw4">typedef</span> <span class="kw4">struct</span> _zend_function_state <span class="br0">&#123;</span>
    zend_function <span class="sy0">*</span><span class="kw2">function</span><span class="sy0">;</span>
    <span class="kw4">void</span> <span class="sy0">**</span>arguments<span class="sy0">;</span>
<span class="br0">&#125;</span> zend_function_state<span class="sy0">;</span></pre>

<p>**arguments是一个指向函数参数的指针，而函数体本身则存储于*function中， *function是一个zend_function结构体，
它最终存储了用户自定义函数的一切信息，它的具体结构是这样的：</p>

<pre class="c"><span class="kw4">typedef</span> <span class="kw4">union</span> _zend_function <span class="br0">&#123;</span>
    zend_uchar type<span class="sy0">;</span>    <span class="coMULTI">/* MUST be the first element of this struct! */</span>
&nbsp;
    <span class="kw4">struct</span> <span class="br0">&#123;</span>
        zend_uchar type<span class="sy0">;</span>  <span class="coMULTI">/* never used */</span>
        <span class="kw4">char</span> <span class="sy0">*</span>function_name<span class="sy0">;</span>    <span class="co1">//函数名称</span>
        zend_class_entry <span class="sy0">*</span>scope<span class="sy0">;</span> <span class="co1">//函数所在的类作用域</span>
        zend_uint fn_flags<span class="sy0">;</span>     <span class="co1">//函数类型，如用户自定义则为 #define ZEND_USER_FUNCTION 2  </span>
        <span class="kw4">union</span> _zend_function <span class="sy0">*</span>prototype<span class="sy0">;</span> <span class="co1">//函数原型</span>
        zend_uint num_args<span class="sy0">;</span>     <span class="co1">//参数数目</span>
        zend_uint required_num_args<span class="sy0">;</span> <span class="co1">//需要的参数数目</span>
        zend_arg_info <span class="sy0">*</span>arg_info<span class="sy0">;</span>  <span class="co1">//参数信息指针</span>
        zend_bool pass_rest_by_reference<span class="sy0">;</span>
        <span class="kw4">unsigned</span> <span class="kw4">char</span> return_reference<span class="sy0">;</span>  <span class="co1">//返回值 </span>
    <span class="br0">&#125;</span> common<span class="sy0">;</span>
&nbsp;
    zend_op_array op_array<span class="sy0">;</span>   <span class="co1">//函数中的操作</span>
    zend_internal_function internal_function<span class="sy0">;</span>  
<span class="br0">&#125;</span> zend_function<span class="sy0">;</span></pre>

<p><em>zend_function</em>的结构中的op_array存储了该函数中所有的操作，当函数被调用时，ZE就会将这个op_array中的opline一条条顺次执行，
并将最后的返回值返回。
从VLD扩展中查看的关于函数的信息可以看出，函数的定义和执行是分开的，一个函数可以作为一个独立的运行单元而存在。</p>

<h3>2.内部函数(ZEND_INTERNAL_FUNCTION)<a name='2.内部函数(ZEND_INTERNAL_FUNCTION)'></a></h3>

<p>ZEND_INTERNAL_FUNCTION函数是由扩展或者Zend/PHP内核提供的，用“C/C++”编写的，可以直接执行的函数。如下为内部函数的结构：</p>

<pre class="c"><span class="kw4">typedef</span> <span class="kw4">struct</span> _zend_internal_function <span class="br0">&#123;</span>
    <span class="coMULTI">/* Common elements */</span>
    zend_uchar type<span class="sy0">;</span>
    <span class="kw4">char</span> <span class="sy0">*</span> function_name<span class="sy0">;</span>
    zend_class_entry <span class="sy0">*</span>scope<span class="sy0">;</span>
    zend_uint fn_flags<span class="sy0">;</span>
    <span class="kw4">union</span> _zend_function <span class="sy0">*</span>prototype<span class="sy0">;</span>
    zend_uint num_args<span class="sy0">;</span>
    zend_uint required_num_args<span class="sy0">;</span>
    zend_arg_info <span class="sy0">*</span>arg_info<span class="sy0">;</span>
    zend_bool pass_rest_by_reference<span class="sy0">;</span>
    <span class="kw4">unsigned</span> <span class="kw4">char</span> return_reference<span class="sy0">;</span>
    <span class="coMULTI">/* END of common elements */</span>
&nbsp;
    <span class="kw4">void</span> <span class="br0">&#40;</span><span class="sy0">*</span>handler<span class="br0">&#41;</span><span class="br0">&#40;</span>INTERNAL_FUNCTION_PARAMETERS<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw4">struct</span> _zend_module_entry <span class="sy0">*</span>module<span class="sy0">;</span>
<span class="br0">&#125;</span> zend_internal_function<span class="sy0">;</span></pre>

<p>最常见的操作是在模块初始化时，ZE会遍历每个载入的扩展模块，然后将模块中function_entry中指明的每一个函数(module->functions)，
创建一个zend_internal_function结构， 并将其type设置为ZEND_INTERNAL_FUNCTION，将这个结构填入全局的函数表(HashTable结构）;
函数设置及注册过程见 Zend/zend_API.c文件中的 <strong>zend_register_functions</strong>函数。这个函数除了处理函数，也处理类的方法，包括那些魔术方法。</p>

<p>内部函数的结构与用户自定义的函数结构基本类似，有一些不同，</p>

<ul>
<li>调用方法，handler字段. 如果是ZEND_INTERNAL_FUNCTION， 那么ZE就调用zend_execute_internal，通过zend_internal_function.handler来执行这个函数。
而用户自定义的函数需要生成中间代码，然后通过中间代码映射到相对就把方法调用。</li>
<li>内置函数在结构中多了一个module字段，表示属于哪个模块。不同的扩展其模块不同。</li>
<li>type字段，在用户自定义的函数中，type字段几科无用，而内置函数中的type字段作为几种内部函数的区分。</li>
</ul>

<h3>3.变量函数<a name='3.变量函数'></a></h3>

<p>PHP 支持变量函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且将尝试执行它。
除此之外，这个可以被用于实现回调函数，函数表等。
对比使用变量函数和内部函数的调用：</p>

<p>变量函数$func</p>

<pre class="php"><span class="re0">$func</span> <span class="sy0">=</span> <span class="st_h">'print_r'</span><span class="sy0">;</span>
<span class="re0">$func</span><span class="br0">&#40;</span><span class="st_h">'i am print_r function.'</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>通过VLD来查看这段代码编译后的中间代码：</p>

<pre class="c"><span class="kw2">function</span> name<span class="sy0">:</span>  <span class="br0">&#40;</span><span class="kw2">null</span><span class="br0">&#41;</span>
number of ops<span class="sy0">:</span>  <span class="nu0">9</span>
compiled vars<span class="sy0">:</span>  <span class="sy0">!</span><span class="nu0">0</span> <span class="sy0">=</span> $func
line     <span class="co2"># *  op                           fetch          ext  return  operands</span>
<span class="sy0">--------------------------------------------------------------------------------</span>
<span class="sy0">-</span>
   <span class="nu0">2</span>     <span class="nu0">0</span>  <span class="sy0">&gt;</span>   EXT_STMT
         <span class="nu0">1</span>      ASSIGN                                                   <span class="sy0">!</span><span class="nu0">0</span><span class="sy0">,</span> <span class="st0">'print_r'</span>
   <span class="nu0">3</span>     <span class="nu0">2</span>      EXT_STMT
         <span class="nu0">3</span>      INIT_FCALL_BY_NAME                                       <span class="sy0">!</span><span class="nu0">0</span>
         <span class="nu0">4</span>      EXT_FCALL_BEGIN
         <span class="nu0">5</span>      SEND_VAL                                                 <span class="st0">'i+am+print_r+function.'</span>
         <span class="nu0">6</span>      DO_FCALL_BY_NAME                              <span class="nu0">1</span>
         <span class="nu0">7</span>      EXT_FCALL_END
         <span class="nu0">8</span>    <span class="sy0">&gt;</span> <span class="kw1">RETURN</span>                                                   <span class="nu0">1</span></pre>

<p>内部函数print_r</p>

<pre class="php"><a href="http://www.php.net/print_r"><span class="kw3">print_r</span></a><span class="br0">&#40;</span><span class="st_h">'i am print_r function.'</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>通过VLD来查看这段代码编译后的中间代码：</p>

<pre class="c"><span class="kw2">function</span> name<span class="sy0">:</span>  <span class="br0">&#40;</span><span class="kw2">null</span><span class="br0">&#41;</span>
number of ops<span class="sy0">:</span>  <span class="nu0">6</span>
compiled vars<span class="sy0">:</span>  none
line     <span class="co2"># *  op                           fetch          ext  return  operands</span>
<span class="sy0">--------------------------------------------------------------------------------</span>
<span class="sy0">-</span>
   <span class="nu0">2</span>     <span class="nu0">0</span>  <span class="sy0">&gt;</span>   EXT_STMT
         <span class="nu0">1</span>      EXT_FCALL_BEGIN
         <span class="nu0">2</span>      SEND_VAL                                                 <span class="st0">'i+am+print_r+function.'</span>
         <span class="nu0">3</span>      DO_FCALL                                      <span class="nu0">1</span>          <span class="st0">'print_r'</span>
         <span class="nu0">4</span>      EXT_FCALL_END
         <span class="nu0">5</span>    <span class="sy0">&gt;</span> <span class="kw1">RETURN</span>                                                   <span class="nu0">1</span></pre>

<p>对比发现，二者在调用的中间代码上存在一些区别。变量函数是DO_FCALL_BY_NAME，而内部函数是DO_FCALL。
这在语法解析时就已经决定了，
见Zend/zend_complie.c文件的zend_do_end_function_call函数中部分代码：</p>

<pre class="c"><span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span>is_method <span class="sy0">&amp;&amp;</span> <span class="sy0">!</span>is_dynamic_fcall <span class="sy0">&amp;&amp;</span> function_name<span class="sy0">-&gt;</span>op_type<span class="sy0">==</span>IS_CONST<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        opline<span class="sy0">-&gt;</span>opcode <span class="sy0">=</span> ZEND_DO_FCALL<span class="sy0">;</span>
        opline<span class="sy0">-&gt;</span>op1 <span class="sy0">=</span> <span class="sy0">*</span>function_name<span class="sy0">;</span>
        ZVAL_LONG<span class="br0">&#40;</span><span class="sy0">&amp;</span>opline<span class="sy0">-&gt;</span>op2.<span class="me1">u</span>.<span class="me1">constant</span><span class="sy0">,</span> zend_hash_func<span class="br0">&#40;</span>Z_STRVAL<span class="br0">&#40;</span>function_name<span class="sy0">-&gt;</span>u.<span class="me1">constant</span><span class="br0">&#41;</span><span class="sy0">,</span> Z_STRLEN<span class="br0">&#40;</span>function_name<span class="sy0">-&gt;</span>u.<span class="me1">constant</span><span class="br0">&#41;</span> <span class="sy0">+</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span> <span class="kw1">else</span> <span class="br0">&#123;</span>
        opline<span class="sy0">-&gt;</span>opcode <span class="sy0">=</span> ZEND_DO_FCALL_BY_NAME<span class="sy0">;</span>
        SET_UNUSED<span class="br0">&#40;</span>opline<span class="sy0">-&gt;</span>op1<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="br0">&#125;</span></pre>

<p>如果不是方法，并且不是动态调用，并且函数名为字符串常量，则其生成的中间代码为ZEND_DO_FCALL。其它情况则为ZEND_DO_FCALL_BY_NAME。
另外将变量函数作为回调函数，其处理过程在Zend/zend_complie.c文件的zend_do_pass_param函数中。
最终会体现在中间代码执行过程中的 <strong>ZEND_SEND_VAL_SPEC_CONST_HANDLER</strong>　等函数中。</p>

<h3>4.匿名函数<a name='4.匿名函数'></a></h3>

<p>匿名函数是一类不需要指定表示符，而又可以被调用的函数或子例程，匿名函数可以方便的作为参数传递给其他函数，
关于匿名函数的详细信息请阅读 <a href="?p=chapt04/04-04-anonymous-function">&lt;&lt;第四节 匿名函数及闭包>></a></p>
		</div>
	</body>
</html>
