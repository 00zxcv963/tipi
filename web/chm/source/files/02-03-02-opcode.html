<!DOCTYPE html>
<html>
<head>
	<title>TIPI: 深入理解PHP内核</title>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<link href="chm.css" media="screen" rel="stylesheet" type="text/css" />
<link href="highlight.css" media="screen" rel="stylesheet" type="text/css" />
</head>
<body id="portable" class="pdf">
			<div class='page '>
			<h3>opcode<a name='opcode'></a></h3>

<p><a href="http://en.wikipedia.org/wiki/Opcode">opcode</a>是计算机指令中的一部分，用于指定要执行的操作，
指令的格式和规范由处理器的指令规范指定。 除了指令本身以外通常还有指令所需要的操作数，可能有的指令不需要显式的操作数。
这些操作数可能是寄存器中的值，堆栈中的值，某块内存的值或者IO端口中的值等等。</p>

<p>通常opcode还有另一种称谓: 字节码(byte codes)。 例如Java虚拟机(JVM)，.NET的通用中间语言(CIL: Common Intermeditate Language)等等。</p>

<h4>PHP的opcode<a name='PHP的opcode'></a></h4>

<p>PHP中的opcode则属于前面介绍中的后着，PHP是构建在Zend虚拟机(Zend VM)之上的。PHP的opcode就是Zend虚拟机中的指令。</p>

<blockquote class='note'>
<p>有关Zend虚拟机的介绍请阅读后面相关内容</p>
</blockquote>

<p>在PHP实现内部，opcode由如下的结构体表示：</p>

<pre class="c"><span class="kw4">struct</span> _zend_op <span class="br0">&#123;</span>
    opcode_handler_t handler<span class="sy0">;</span> <span class="co1">// 执行该opcode时调用的处理函数</span>
    znode result<span class="sy0">;</span>
    znode op1<span class="sy0">;</span>
    znode op2<span class="sy0">;</span>
    ulong extended_value<span class="sy0">;</span>
    uint lineno<span class="sy0">;</span>
    zend_uchar opcode<span class="sy0">;</span>  <span class="co1">// opcode代码</span>
<span class="br0">&#125;</span><span class="sy0">;</span></pre>

<p>和CPU的指令类似，有一个标示指令的opcode字段，以及这个opcode所操作的操作数，PHP不像汇编那么底层，
在脚本实际执行的时候可能还需要其他更多的信息，extended_value字段就保存了这类信息，
其中的result域则是保存该指令执行完成后的结果。</p>

<p>例如如下代码是在编译器遇到print语句的时候进行编译的函数:</p>

<pre class="c"><span class="kw4">void</span> zend_do_print<span class="br0">&#40;</span>znode <span class="sy0">*</span>result，<span class="kw4">const</span> znode <span class="sy0">*</span>arg TSRMLS_DC<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    zend_op <span class="sy0">*</span>opline <span class="sy0">=</span> get_next_op<span class="br0">&#40;</span>CG<span class="br0">&#40;</span>active_op_array<span class="br0">&#41;</span> TSRMLS_CC<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    opline<span class="sy0">-&gt;</span>result.<span class="me1">op_type</span> <span class="sy0">=</span> IS_TMP_VAR<span class="sy0">;</span>
    opline<span class="sy0">-&gt;</span>result.<span class="me1">u</span>.<span class="me1">var</span> <span class="sy0">=</span> get_temporary_variable<span class="br0">&#40;</span>CG<span class="br0">&#40;</span>active_op_array<span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy0">;</span>
    opline<span class="sy0">-&gt;</span>opcode <span class="sy0">=</span> ZEND_PRINT<span class="sy0">;</span>
    opline<span class="sy0">-&gt;</span>op1 <span class="sy0">=</span> <span class="sy0">*</span>arg<span class="sy0">;</span>
    SET_UNUSED<span class="br0">&#40;</span>opline<span class="sy0">-&gt;</span>op2<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="sy0">*</span>result <span class="sy0">=</span> opline<span class="sy0">-&gt;</span>result<span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>这个函数新创建一条zend_op，将返回值的类型设置为临时变量(IS_TMP_VAR)，并为临时变量申请空间，
随后指定opcode为ZEND_PRINT，并将传递进来的参数赋值给这条opcode的第一个操作数。这样在最终执行这条opcode的时候，
Zend引擎能获取到足够的信息以便输出内容。</p>

<p>下面这个函数是在编译器遇到echo语句的时候进行编译的函数:</p>

<pre class="c"><span class="kw4">void</span> zend_do_echo<span class="br0">&#40;</span><span class="kw4">const</span> znode <span class="sy0">*</span>arg TSRMLS_DC<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    zend_op <span class="sy0">*</span>opline <span class="sy0">=</span> get_next_op<span class="br0">&#40;</span>CG<span class="br0">&#40;</span>active_op_array<span class="br0">&#41;</span> TSRMLS_CC<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
    opline<span class="sy0">-&gt;</span>opcode <span class="sy0">=</span> ZEND_ECHO<span class="sy0">;</span>
    opline<span class="sy0">-&gt;</span>op1 <span class="sy0">=</span> <span class="sy0">*</span>arg<span class="sy0">;</span>
    SET_UNUSED<span class="br0">&#40;</span>opline<span class="sy0">-&gt;</span>op2<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="br0">&#125;</span></pre>

<p>可以看到echo处理除了指定opcode以外，还将echo的参数传递给op1，这里并没有设置opcode的result结果字段。
从这里我们也能看出print和echo的区别来，print有返回值，而echo没有，这里的没有和返回null是不同的，
如果尝试将echo的值赋值给某个变量或者传递给函数都会出现语法错误。</p>

<p>PHP脚本编译为opcode保存在op_array中，其内部存储的结构如下：</p>

<pre class="c"><span class="kw4">struct</span> _zend_op_array <span class="br0">&#123;</span>
    <span class="coMULTI">/* Common elements */</span>
    zend_uchar type<span class="sy0">;</span>
    <span class="kw4">char</span> <span class="sy0">*</span>function_name<span class="sy0">;</span>  <span class="co1">// 如果是用户定义的函数则，这里将保存函数的名字</span>
    zend_class_entry <span class="sy0">*</span>scope<span class="sy0">;</span>
    zend_uint fn_flags<span class="sy0">;</span>
    <span class="kw4">union</span> _zend_function <span class="sy0">*</span>prototype<span class="sy0">;</span>
    zend_uint num_args<span class="sy0">;</span>
    zend_uint required_num_args<span class="sy0">;</span>
    zend_arg_info <span class="sy0">*</span>arg_info<span class="sy0">;</span>
    zend_bool pass_rest_by_reference<span class="sy0">;</span>
    <span class="kw4">unsigned</span> <span class="kw4">char</span> return_reference<span class="sy0">;</span>
    <span class="coMULTI">/* END of common elements */</span>
&nbsp;
    zend_bool done_pass_two<span class="sy0">;</span>
&nbsp;
    zend_uint <span class="sy0">*</span>refcount<span class="sy0">;</span>
&nbsp;
    zend_op <span class="sy0">*</span>opcodes<span class="sy0">;</span>  <span class="co1">// opcode数组</span>
&nbsp;
    zend_uint last，size<span class="sy0">;</span>
&nbsp;
    zend_compiled_variable <span class="sy0">*</span>vars<span class="sy0">;</span>
    <span class="kw4">int</span> last_var，size_var<span class="sy0">;</span>
&nbsp;
    <span class="co1">// ...</span>
<span class="br0">&#125;</span></pre>

<p>如上面的注释，opcodes保存在这里，在执行的时候由下面的execute函数执行：</p>

<pre class="c">ZEND_API <span class="kw4">void</span> execute<span class="br0">&#40;</span>zend_op_array <span class="sy0">*</span>op_array TSRMLS_DC<span class="br0">&#41;</span>
<span class="br0">&#123;</span>
    <span class="co1">// ... 循环执行op_array中的opcode或者执行其他op_array中的opcode</span>
<span class="br0">&#125;</span></pre>

<p>前面提到每条opcode都有一个opcode_handler_t的函数指针字段，用于执行该opcode，
这里并没有给没有指定处理函数，那在执行的时候该由哪个函数来执行呢?
更多信息请参考Zend虚拟机相关章节的详细介绍。虚拟机相关章节的详细介绍。</p>

<blockquote class='note'>
<p>PHP有三种方式来进行opcode的处理:CALL，SWITCH和GOTO，PHP默认使用CALL的方式，也就是函数调用的方式，
  由于opcode执行是每个PHP程序频繁需要进行的操作，可以使用SWITCH或者GOTO的方式来分发，
  通常GOTO的效率相对会高一些，不过效率是否提高依赖于不同的CPU。</p>
</blockquote>
		</div>
	</body>
</html>
