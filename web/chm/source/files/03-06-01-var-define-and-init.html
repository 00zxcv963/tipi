<!DOCTYPE html>
<html>
<head>
	<title>TIPI: 深入理解PHP内核</title>
	<meta http-equiv="Content-type" content="text/html; charset=utf-8">
	<link href="chm.css" media="screen" rel="stylesheet" type="text/css" />
<link href="highlight.css" media="screen" rel="stylesheet" type="text/css" />
</head>
<body id="portable" class="pdf">
			<div class='page '>
			<h3>变量的赋值和销毁<a name='变量的赋值和销毁'></a></h3>

<p>在强类型的语言当中，当使用一个变量之前，我们需要先声明这个变量。然而，对于PHP来说，
在使用一个变量时，我们不需要声明，也不需要初始化，直接对其赋值就可以使用，这是如何实现的？</p>

<h4>变量的声明和赋值<a name='变量的声明和赋值'></a></h4>

<p>在PHP中没有对常规变量的声明操作，如果要使用一个变量，直接进行赋值操作即可。在赋值操作的同时已经进行声明操作。
一个简单的赋值操作：</p>

<pre class="php"><span class="re0">$a</span> <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span></pre>

<p>使用VLD扩展查看其生成的中间代码为 <strong>ASSIGN</strong>。
依此，我们找到其执行的函数为 <strong>ZEND_ASSIGN_SPEC_CV_CONST_HANDLER</strong>。
（找到这个函数的方法之一：$a为CV，10为CONST，操作为ASSIGN。
其他方法可以参见<a href="?p=chapt02/02-03-03-from-opcode-to-handler">附：找到Opcode具体实现</a>）
CV是PHP在5.1后增加的一个在编译期的缓存。如我们在使用VLD查看上面的PHP代码生成的中间代码时会看到：</p>

<pre class="c">compiled vars<span class="sy0">:</span>  <span class="sy0">!</span><span class="nu0">0</span> <span class="sy0">=</span> $a</pre>

<p>这个$a变量就是op_type为IS_CV的变量。</p>

<blockquote class='note'>
<p>IS_CV值的设置是在语法解析时进行的。<br />
  参见Zend/zend_complie.c文件中的zend_do_end_variable_parse函数。</p>
</blockquote>

<p>在这个函数中，获取这个赋值操作的左值和右值的代码为：</p>

<pre class="c">zval <span class="sy0">*</span>value <span class="sy0">=</span> <span class="sy0">&amp;</span>opline<span class="sy0">-&gt;</span>op2.<span class="me1">u</span>.<span class="me1">constant</span><span class="sy0">;</span>
zval <span class="sy0">**</span>variable_ptr_ptr <span class="sy0">=</span> _get_zval_ptr_ptr_cv<span class="br0">&#40;</span><span class="sy0">&amp;</span>opline<span class="sy0">-&gt;</span>op1<span class="sy0">,</span> 
                                    EX<span class="br0">&#40;</span>Ts<span class="br0">&#41;</span><span class="sy0">,</span> BP_VAR_W TSRMLS_CC<span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>由于右值为一个数值，我们可以理解为一个常量，则直接取操作数存储的constant字段，
关于这个字段的说明将在后面的虚拟机章节说明。
左值是通过 _get_zval_ptr_ptr_cv函数获取zval值。这个函数最后的调用顺序为：
[_get_zval_ptr_ptr_cv] --> [_get_zval_cv_lookup]</p>

<p>在_get_zval_cv_lookup函数中关键代码为：</p>

<pre class="c">zend_hash_quick_find<span class="br0">&#40;</span>EG<span class="br0">&#40;</span>active_symbol_table<span class="br0">&#41;</span><span class="sy0">,</span> cv<span class="sy0">-&gt;</span>name<span class="sy0">,</span> cv<span class="sy0">-&gt;</span>name_len<span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> 
                                    cv<span class="sy0">-&gt;</span>hash_value<span class="sy0">,</span> <span class="br0">&#40;</span><span class="kw4">void</span> <span class="sy0">**</span><span class="br0">&#41;</span>ptr<span class="br0">&#41;</span></pre>

<p>这是一个HashTable的查找函数，它的作用是从EG(active_symbol_table)中查找名称为cv->name的变量，并将这个值赋值给ptr。
最后，这个在符号表中找到的值将传递给ZEND_ASSIGN_SPEC_CV_CONST_HANDLER函数的variable_ptr_ptr变量。</p>

<p>以上是获取左值和右值的过程，在这步操作后将执行赋值操作的核心操作--赋值。赋值操作是通过调用zend_assign_to_variable函数实现。
在zend_assign_to_variable函数中，赋值操作分为好几种情况来处理，在程序中就是以几层的if语句体现。</p>

<h5>情况一：赋值的左值存在引用（即zval变量中is_ref__gc字段不为0），并且左值不等于右值<a name='情况一：赋值的左值存在引用（即zval变量中is_ref__gc字段不为0），并且左值不等于右值'></a></h5>

<p>这种情形描述起来比较抽象，如下面的示例：</p>

<pre class="php"><span class="re0">$a</span> <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
<span class="re0">$b</span> <span class="sy0">=</span> <span class="sy0">&amp;</span><span class="re0">$a</span><span class="sy0">;</span>
&nbsp;
xdebug_debug_zval<span class="br0">&#40;</span><span class="st_h">'a'</span><span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
<span class="re0">$a</span> <span class="sy0">=</span> <span class="nu0">20</span><span class="sy0">;</span>
xdebug_debug_zval<span class="br0">&#40;</span><span class="st_h">'a'</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>试想，如果我们来做这个<strong>$b = &amp;$a;</strong>的底层实现，我们可能会这样做：</p>

<ul>
<li>判断左值是不是已经被引用过了;</li>
<li>左值已经被引用，则不改变左值的引用计数，将右值赋与左值;</li>
</ul>

<p>事实上，ZE也是用同样的方法来实现，其代码如下：</p>

<pre class="c"><span class="kw1">if</span> <span class="br0">&#40;</span>PZVAL_IS_REF<span class="br0">&#40;</span>variable_ptr<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>variable_ptr<span class="sy0">!=</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        zend_uint refcount <span class="sy0">=</span> Z_REFCOUNT_P<span class="br0">&#40;</span>variable_ptr<span class="br0">&#41;</span><span class="sy0">;</span>
&nbsp;
        garbage <span class="sy0">=</span> <span class="sy0">*</span>variable_ptr<span class="sy0">;</span>
        <span class="sy0">*</span>variable_ptr <span class="sy0">=</span> <span class="sy0">*</span>value<span class="sy0">;</span>
        Z_SET_REFCOUNT_P<span class="br0">&#40;</span>variable_ptr<span class="sy0">,</span> refcount<span class="br0">&#41;</span><span class="sy0">;</span>
        Z_SET_ISREF_P<span class="br0">&#40;</span>variable_ptr<span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span>is_tmp_var<span class="br0">&#41;</span> <span class="br0">&#123;</span>
            zendi_zval_copy_ctor<span class="br0">&#40;</span><span class="sy0">*</span>variable_ptr<span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="br0">&#125;</span>
        zendi_zval_dtor<span class="br0">&#40;</span>garbage<span class="br0">&#41;</span><span class="sy0">;</span>
        <span class="kw1">return</span> variable_ptr<span class="sy0">;</span>
    <span class="br0">&#125;</span>
<span class="br0">&#125;</span></pre>

<p>PZVAL_IS_REF(variable_ptr)判断is_ref__gc字段是否为0。在左值不等于右值的情况下执行操作。
所有指向这个zval容器的变量的值都变成了*value。并且引用计数的值不变。下面是这种情况的一个示例：</p>

<p>上面的例子的输出结果：</p>

<pre class="c">a<span class="sy0">:</span>
<span class="br0">&#40;</span>refcount<span class="sy0">=</span><span class="nu0">2</span><span class="sy0">,</span> is_ref<span class="sy0">=</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="kw4">int</span> <span class="nu0">10</span>
a<span class="sy0">:</span>
<span class="br0">&#40;</span>refcount<span class="sy0">=</span><span class="nu0">2</span><span class="sy0">,</span> is_ref<span class="sy0">=</span><span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">,</span><span class="kw4">int</span> <span class="nu0">20</span></pre>

<h5>情况二：赋值的左值不存在引用，左值的引用计数为1，左值等于右值<a name='情况二：赋值的左值不存在引用，左值的引用计数为1，左值等于右值'></a></h5>

<p>在这种情况下，应该是什么都不会发生吗？看一个示例：</p>

<pre class="php"><span class="re0">$a</span> <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
<span class="re0">$a</span> <span class="sy0">=</span> <span class="re0">$a</span><span class="sy0">;</span></pre>

<p>看上去真的像是什么都没有发生，
左值的引用计数还是1，值仍是10 。
然而在这个赋值过程中，$a的引用计数经历了一次加一和一次减一的操作。
如以下代码：</p>

<pre class="c"><span class="kw1">if</span> <span class="br0">&#40;</span>Z_DELREF_P<span class="br0">&#40;</span>variable_ptr<span class="br0">&#41;</span><span class="sy0">==</span><span class="nu0">0</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>  <span class="co1">//  引用计数减一操作</span>
        <span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy0">!</span>is_tmp_var<span class="br0">&#41;</span> <span class="br0">&#123;</span>
            <span class="kw1">if</span> <span class="br0">&#40;</span>variable_ptr<span class="sy0">==</span>value<span class="br0">&#41;</span> <span class="br0">&#123;</span>
                Z_ADDREF_P<span class="br0">&#40;</span>variable_ptr<span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">//  引用计数加一操作</span>
            <span class="br0">&#125;</span>
...<span class="co1">//省略</span></pre>

<h5>情况三：赋值的左值不存在引用，左值的引用计数为1，右值存在引用<a name='情况三：赋值的左值不存在引用，左值的引用计数为1，右值存在引用'></a></h5>

<p>用一个PHP的示例来描述一下这种情况：</p>

<pre class="php"><span class="re0">$a</span> <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
<span class="re0">$b</span> <span class="sy0">=</span> <span class="sy0">&amp;</span><span class="re0">$a</span><span class="sy0">;</span>
<span class="re0">$c</span> <span class="sy0">=</span> <span class="re0">$a</span><span class="sy0">;</span></pre>

<p>这里的<strong>$c = $a;</strong>的操作就是我们所示的第三种情况。
对于这种情况，ZEND内核直接创建一个新的zval容器，左值的值为右值，并且左值的引用计数为1。
也就是说，这种情形$c不会与$a指向同一个zval。
其内核实现代码如下：</p>

<pre class="c">&nbsp;
garbage <span class="sy0">=</span> <span class="sy0">*</span>variable_ptr<span class="sy0">;</span>
<span class="sy0">*</span>variable_ptr <span class="sy0">=</span> <span class="sy0">*</span>value<span class="sy0">;</span>
INIT_PZVAL<span class="br0">&#40;</span>variable_ptr<span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">//  初始化一个新的zval变量容器</span>
zval_copy_ctor<span class="br0">&#40;</span>variable_ptr<span class="br0">&#41;</span><span class="sy0">;</span>   
zendi_zval_dtor<span class="br0">&#40;</span>garbage<span class="br0">&#41;</span><span class="sy0">;</span>
<span class="kw1">return</span> variable_ptr<span class="sy0">;</span></pre>

<blockquote class='question'>
<p>在这个例子中，若将 <strong>$c = $a;</strong> 换成 <strong>$c = &amp;$a;</strong>，$a，$b和$c三个变量的引用计数会发生什么变化？<br />
  将 <strong>$b = &amp;$a</strong>; 换成 <strong>$b = $a;</strong> 呢？<br />
  大家可以将答案回复在下面：）</p>
</blockquote>

<h5>情况四：赋值的左值不存在引用，左值的引用计数为1，右值不存在引用<a name='情况四：赋值的左值不存在引用，左值的引用计数为1，右值不存在引用'></a></h5>

<p>这种情形如下面的例子：</p>

<pre class="php"><span class="re0">$a</span> <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
<span class="re0">$c</span> <span class="sy0">=</span> <span class="re0">$a</span><span class="sy0">;</span></pre>

<p>这时，右值的引用计数加上，一般情况下，会对左值进行垃圾收集操作，将其移入垃圾缓冲池。垃圾缓冲池的功能是在PHP5.3后才有的。
在PHP内核中的代码体现为：</p>

<pre class="c">Z_ADDREF_P<span class="br0">&#40;</span>value<span class="br0">&#41;</span><span class="sy0">;</span>  <span class="co1">//  引用计数加1</span>
<span class="sy0">*</span>variable_ptr_ptr <span class="sy0">=</span> value<span class="sy0">;</span>
<span class="kw1">if</span> <span class="br0">&#40;</span>variable_ptr <span class="sy0">!=</span> <span class="sy0">&amp;</span>EG<span class="br0">&#40;</span>uninitialized_zval<span class="br0">&#41;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
    GC_REMOVE_ZVAL_FROM_BUFFER<span class="br0">&#40;</span>variable_ptr<span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">//  调用垃圾收集机制</span>
    zval_dtor<span class="br0">&#40;</span>variable_ptr<span class="br0">&#41;</span><span class="sy0">;</span>
    efree<span class="br0">&#40;</span>variable_ptr<span class="br0">&#41;</span><span class="sy0">;</span>    <span class="co1">//  释放变量内存空间</span>
<span class="br0">&#125;</span>
<span class="kw1">return</span> value<span class="sy0">;</span></pre>

<h5>情况五：赋值的左值不存在引用，左值的引用计数为大于0，右值存在引用，并且引用计数大于0<a name='情况五：赋值的左值不存在引用，左值的引用计数为大于0，右值存在引用，并且引用计数大于0'></a></h5>

<p>一个演示这种情况的PHP示例：</p>

<pre class="php"><span class="re0">$a</span> <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
<span class="re0">$b</span> <span class="sy0">=</span> <span class="re0">$a</span><span class="sy0">;</span>
<span class="re0">$va</span> <span class="sy0">=</span> <span class="nu0">20</span><span class="sy0">;</span>
<span class="re0">$vb</span> <span class="sy0">=</span> <span class="sy0">&amp;</span><span class="re0">$va</span><span class="sy0">;</span>
&nbsp;
<span class="re0">$a</span> <span class="sy0">=</span> <span class="re0">$va</span><span class="sy0">;</span></pre>

<p>最后一个操作就是我们的情况五。
使用xdebug看引用计数发现，最终$a变量的引用计数为1，$va变量的引用计数为2，并且$va存在引用。
从源码层分析这个原因：</p>

<pre class="c">ALLOC_ZVAL<span class="br0">&#40;</span>variable_ptr<span class="br0">&#41;</span><span class="sy0">;</span>   <span class="co1">//  分配新的zval容器</span>
<span class="sy0">*</span>variable_ptr_ptr <span class="sy0">=</span> variable_ptr<span class="sy0">;</span>
<span class="sy0">*</span>variable_ptr <span class="sy0">=</span> <span class="sy0">*</span>value<span class="sy0">;</span>
zval_copy_ctor<span class="br0">&#40;</span>variable_ptr<span class="br0">&#41;</span><span class="sy0">;</span>
Z_SET_REFCOUNT_P<span class="br0">&#40;</span>variable_ptr<span class="sy0">,</span> <span class="nu0">1</span><span class="br0">&#41;</span><span class="sy0">;</span>  <span class="co1">//  设置引用计数为1</span></pre>

<p>从代码可以看出是新分配了一个zval容器，并设置了引用计数为1，印证了我们之前的例子$a变量的结果。</p>

<p>除上述五种情况之外，<strong>zend_assign_to_variable</strong>函数还对全部的临时变量做了处理。
变量赋值的各种操作全部由此函数完成。</p>

<h4>变量的销毁<a name='变量的销毁'></a></h4>

<p>在PHP中销毁变量最常用的方法是使用unset函数。
unset函数并不是一个真正意义上的函数，它是一种语言结构。
在使用此函数时，它会根据变量的不同触发不同的操作。</p>

<p>一个简洁的例子：</p>

<pre class="php"><span class="re0">$a</span> <span class="sy0">=</span> <span class="nu0">10</span><span class="sy0">;</span>
<a href="http://www.php.net/unset"><span class="kw3">unset</span></a><span class="br0">&#40;</span><span class="re0">$a</span><span class="br0">&#41;</span><span class="sy0">;</span></pre>

<p>使用VLD扩展查看其生成的中间代码：</p>

<pre class="txt">compiled vars:  !0 = $a
line     # *  op                           fetch          ext  return  operands
---------------------------------------------------------------------------------
   2     0  &gt;   EXT_STMT
         1      ASSIGN                                                   !0, 10
   3     2      EXT_STMT
         3      UNSET_VAR                                                !0
         4    &gt; RETURN                                                   1</pre>

<p>去掉关于赋值的中间代码，得到unset函数生成的中间代码为 <strong>UNSET_VAR</strong>，由于我们unse的是一个变量，
在Zend/zend_vm_execute.h文件中查找到其最终调用的执行中间代码的函数为： <strong>ZEND_UNSET_VAR_SPEC_CV_HANDLER</strong>
关键代码代码如下：</p>

<pre class="c">target_symbol_table <span class="sy0">=</span> zend_get_target_symbol_table<span class="br0">&#40;</span>opline<span class="sy0">,</span> EX<span class="br0">&#40;</span>Ts<span class="br0">&#41;</span><span class="sy0">,</span>
        BP_VAR_IS<span class="sy0">,</span> varname TSRMLS_CC<span class="br0">&#41;</span><span class="sy0">;</span>
    <span class="kw1">if</span> <span class="br0">&#40;</span>zend_hash_quick_del<span class="br0">&#40;</span>target_symbol_table<span class="sy0">,</span> varname<span class="sy0">-&gt;</span>value.<span class="me1">str</span>.<span class="me1">val</span><span class="sy0">,</span>
            varname<span class="sy0">-&gt;</span>value.<span class="me1">str</span>.<span class="me1">len</span><span class="sy0">+</span><span class="nu0">1</span><span class="sy0">,</span> hash_value<span class="br0">&#41;</span> <span class="sy0">==</span> SUCCESS<span class="br0">&#41;</span> <span class="br0">&#123;</span>
        ...<span class="co1">//省略</span>
    <span class="br0">&#125;</span></pre>

<p>程序会先获取目标符号表，这个符号表是一个HashTable，然后将我们需要unset掉的变量从这个HashTable中删除。</p>

<blockquote class='note'>
<p>变量的销毁还涉及到垃圾回收机制（GC），请参见相关第六章内容
  关于HashTable的操作请参考 <a href="?p=chapt03/03-01-01-hashtable">&lt;&lt; 哈希表(HashTable) >></a>。</p>
</blockquote>
		</div>
	</body>
</html>
